<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Husen&#39;Blog</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.husen.xyz/"/>
  <updated>2018-01-10T09:50:00.349Z</updated>
  <id>http://blog.husen.xyz/</id>
  
  <author>
    <name>可爱的小森森^_^</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP学习笔记二</title>
    <link href="http://blog.husen.xyz/2018/01/10/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://blog.husen.xyz/2018/01/10/HTTP学习笔记二/</id>
    <published>2018-01-10T09:29:49.000Z</published>
    <updated>2018-01-10T09:50:00.349Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP学习笔记二<br><a id="more"></a></p><h2 id="一、URL"><a href="#一、URL" class="headerlink" title="一、URL"></a>一、URL</h2><p>所有人都对这些名字的标准达成了一致，所以才能方便地共享这座城市的宝藏。你告诉出租车司机把你载到McAllister大街246号，他就知道你的意思了（即使他走的是一条很远的路)</p><h3 id="URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。"><a href="#URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。" class="headerlink" title="URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。"></a>URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。</h3><blockquote><p>HTTP URL的路劲组件可以分成若干路径段，每段都可以有自己的参数。比如：<br><a href="http://www.baidu.com;name=sss/index.html;us=22" target="_blank" rel="noopener">http://www.baidu.com;name=sss/index.html;us=22</a></p></blockquote><h3 id="URL结构"><a href="#URL结构" class="headerlink" title="URL结构"></a>URL结构</h3><p>scheme://user:password@host:port/path;params?query#frag</p><ul><li><scheme>方案：访问服务器以获取资源的时候使用哪种协议，默认值无</scheme></li><li><user>用户：某些方案访问资源时需要的用户名，默认值匿名</user></li><li><password>密码：用户名后面可能要包含密码，中间用:分割，默认值E-mail地址</password></li><li><host>主机：资源宿主服务器的主机名或点分Ip地址，默认值无</host></li><li><port>端口：资源宿主服务器正在监听的端口。很多方案都有默认的端口号（HTTP是80）</port></li><li><path></path>路径：服务器上资源的本地名，默认值无</li><li><params>参数：某些方案会用这个组件来指定输入的参数。参数为键=值形式，默认值无</params></li><li><query>查询：某些方案会用这个组件传递参数以激活应用程序。用?将其与URL的其余部分分隔开来，多个用&amp;连接，形式键=值，默认值无</query></li><li><frag>片段：一小片或一部分资源的名字。引用对象时不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其它部分分隔开来，默认值无</frag></li></ul><h2 id="二、报文"><a href="#二、报文" class="headerlink" title="二、报文"></a>二、报文</h2><h3 id="（1）请求报文格式"><a href="#（1）请求报文格式" class="headerlink" title="（1）请求报文格式"></a>（1）请求报文格式</h3><blockquote><p><method> <request-url> <version>   </version></request-url></method></p><headers>  <entity-body></entity-body></headers></blockquote><h3 id="（2）响应报文格式（注意，只有起始行的语法有所不同）"><a href="#（2）响应报文格式（注意，只有起始行的语法有所不同）" class="headerlink" title="（2）响应报文格式（注意，只有起始行的语法有所不同）"></a>（2）响应报文格式（注意，只有起始行的语法有所不同）</h3><blockquote><p><version> <status> <reason-phrase>  </reason-phrase></status></version></p><p><headers>  </headers></p><p>##</p><entity-body></entity-body></blockquote><h3 id="（3）下面对各部分的描述"><a href="#（3）下面对各部分的描述" class="headerlink" title="（3）下面对各部分的描述"></a>（3）下面对各部分的描述</h3><blockquote><ul><li>方法（method）：客户端希望服务器对资源执行的动作。  </li><li>请求URL（request-URL）：命名了所请求的资源，或者URL路径组件的完整URL。  </li><li>版本（version）：报文所使用的HTTP版本，其格式看起来是这样：<br>HTTP/<major>.<minor> 其中主要版本号major和次要版本号minor都是整数。  </minor></major></li><li>状态码（status-code）：这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般列表（“成功”，“出错”等）。  </li><li>原因短语（reason-phrase）：数字状态码的可读版本，包含行终止序列之前的所有文本。  </li><li>首部（header）：可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1要求有效请求或响应报文中必须包含特定的首部。  </li><li>实体的主体部分（entity-body）：实体的主体部分包含了一个任意数据组成的数据块。并不是所有的报文都包含了实体的主体部分，有时，报文只以一个CELF结束。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181881739?method=download&amp;inline=true&amp;version=1&amp;shareToken=899BE9718DEE4A0AB9ECFF1B55A77867" alt="image"></li></ul></blockquote><h2 id="三、状态码"><a href="#三、状态码" class="headerlink" title="三、状态码"></a>三、状态码</h2><p>方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181881798?method=download&amp;inline=true&amp;version=1&amp;shareToken=B3C0BB6F90A7493BBBB5F9DBA1F055D4" alt="image"></p><h3 id="1、100-199——信息状态码"><a href="#1、100-199——信息状态码" class="headerlink" title="1、100~199——信息状态码"></a>1、100~199——信息状态码</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906830?method=download&amp;inline=true&amp;version=1&amp;shareToken=C30FB2943F134A33ABB7A449EC28C114" alt="image"></p></blockquote><h3 id="2、200-299——成功状态码"><a href="#2、200-299——成功状态码" class="headerlink" title="2、200~299——成功状态码"></a>2、200~299——成功状态码</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912059?method=download&amp;inline=true&amp;version=1&amp;shareToken=B60E8C0B082A45C2A21FEB202A412CA1" alt="image"></p></blockquote><h3 id="3、300-399——重定向状态码"><a href="#3、300-399——重定向状态码" class="headerlink" title="3、300~399——重定向状态码"></a>3、300~399——重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应二不是资源的内容。如果资源已被移走，可以发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪里找到它（见图3-14）。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912367?method=download&amp;inline=true&amp;version=1&amp;shareToken=BAF473E6738F4A08813CA56749727C07" alt="image"></p></blockquote><p>可以通过某些重定向的状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。图3-15显示了一个这样的例子。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912726?method=download&amp;inline=true&amp;version=1&amp;shareToken=915E96C94531493BA2CD4727A78E43BE" alt="image"><br>表3-8  重定向状态码与原因短语<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181912956?method=download&amp;inline=true&amp;version=1&amp;shareToken=94C7EDD9D1A44014A9E026108DF5BF30" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181912958?method=download&amp;inline=true&amp;version=1&amp;shareToken=FD881807FE814D749DC55526289E41EE" alt="image"></p></blockquote><h3 id="4、400-499——客户端错误状态码"><a href="#4、400-499——客户端错误状态码" class="headerlink" title="4、400~499——客户端错误状态码"></a>4、400~499——客户端错误状态码</h3><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的就是，请求一个不存在的URL。<br>表3-9 客户端错误状态码及原因短语  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916366?method=download&amp;inline=true&amp;version=1&amp;shareToken=B411435FBD7740FBA9935BD629878439" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916429?method=download&amp;inline=true&amp;version=1&amp;shareToken=45C83F8DF83B4334B5B543E714AA504D" alt="image"></p></blockquote><h3 id="5、500-599——服务器错误状态码"><a href="#5、500-599——服务器错误状态码" class="headerlink" title="5、500~599——服务器错误状态码"></a>5、500~599——服务器错误状态码</h3><p>有时客户端发送了一条有效的请求，服务器自身却出错误了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如，某个网关资源出了错。<br>表3-10 服务器错误状态码及原因短语</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916502?method=download&amp;inline=true&amp;version=1&amp;shareToken=45C3DBA7A1F647A9BE57E3D3D28DAE6E" alt="image"></p></blockquote><p>当前的HTTP版本只为每类状态定义了几个代码。随着协议的发展，HTTP规范中会正式地定义更多的状态码。如果收到不认识的状态码，可能是有人将其当作当前协议的扩展定义的。可以根据其所在的范围，将它作为那个类别中的一个普通的成员来处理。</p><h2 id="四、首部分类"><a href="#四、首部分类" class="headerlink" title="四、首部分类"></a>四、首部分类</h2><p>HTTP规范定义了几种首部字段。应用程序也可以随意的发明自己所用的首部</p><ul><li>首部通用<br>既可以出现在请求报文里，也可以出现在响应报文里。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916543?method=download&amp;inline=true&amp;version=1&amp;shareToken=3A3CC3021D454AFAB6F6D7E249CB9439" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916570?method=download&amp;inline=true&amp;version=1&amp;shareToken=7CA0C21E00E7406EB4C1B67A43DF70A3" alt="image"></p></blockquote></li><li>请求首部<br>提供更多有关请求的信息。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916580?method=download&amp;inline=true&amp;version=1&amp;shareToken=E143E0968D4A4DAB913131D87EB38219" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916687?method=download&amp;inline=true&amp;version=1&amp;shareToken=F83E8568D8634F049830202C297527F3" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916714?method=download&amp;inline=true&amp;version=1&amp;shareToken=A890E4C67C6540379A6270820031B3B9" alt="image"></p></blockquote></li><li>响应首部<br>提供更多有关响应的信息。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916749?method=download&amp;inline=true&amp;version=1&amp;shareToken=0AD17F00A44F4E0BAC0FC0FC52C10DF4" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916794?method=download&amp;inline=true&amp;version=1&amp;shareToken=BF20F488657E463B97572D89FE4C99C9" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181928062?method=download&amp;inline=true&amp;version=1&amp;shareToken=339904B2265D4B2495B049544AF98E10" alt="image"></p></blockquote></li><li>实体首部<br>描述主体的长度和内容，或者资源自身。 <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181928157?method=download&amp;inline=true&amp;version=1&amp;shareToken=D288999643974C39A26549B690799AAA" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181928177?method=download&amp;inline=true&amp;version=1&amp;shareToken=A4B26EAE18C2444A93B9F62A9B75822E" alt="image"></p></blockquote></li><li>扩展首部<br>规范中没有定义的新首部。<br>每个HTTP首部都有一种简单的语法：名字后面跟着冒号（:），然后跟上可选的空格，再跟上字段值，最后是一个CRLF。</li></ul><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181886729?method=download&amp;inline=true&amp;version=1&amp;shareToken=5EC94415A0AB4F8EAF8C86F94884ED3D" alt="image"></p><h2 id="五、实体的主体部分"><a href="#五、实体的主体部分" class="headerlink" title="五、实体的主体部分"></a>五、实体的主体部分</h2><p>HTTP报文的第三部分是可选的实体部分。实体的主体部分是HTTP报文的负荷。就是HTTP要传输的内容</p><p>HTTP报文可以承载很多类型的数字数据：图片、视频、html文档、软件应用程序、信用卡事务、电子邮件等。</p><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h3><blockquote><p>GET是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1要求服务器实现此方法。图3-7显示了一个例子。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181891000?method=download&amp;inline=true&amp;version=1&amp;shareToken=6BEDCC7EE001499FB503EBB5E64C92C7" alt="image"></p></blockquote><h3 id="2-HEAD"><a href="#2-HEAD" class="headerlink" title="2.HEAD"></a>2.HEAD</h3><blockquote><p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。使用HEAD可以：  </p><ul><li>在不获取资源的情况下了解资源的情况（比如，判断其类型）；  </li><li>通过查看响应中的状态码，看看某个对象是否存在；  </li><li>通过查看首部，测试资源是否被修改了。<br>服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循HTTP/1.1规范，就必须实现HEAD方法。图3-8显示了实际的HEAD方法。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181900403?method=download&amp;inline=true&amp;version=1&amp;shareToken=DA050DD77D8F45A79A7C15CCB0CE6602" alt="image"></li></ul></blockquote><h3 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3.PUT"></a>3.PUT</h3><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档。有些发布系统允许用户创建Web页面，并用PUT直接将其安装到Web服务器上去（参加图3-9）。  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181900491?method=download&amp;inline=true&amp;version=1&amp;shareToken=870C8B5810E34B048F7C30807C14AFD0" alt="image"></p></blockquote><h3 id="4-POST"><a href="#4-POST" class="headerlink" title="4.POST"></a>4.POST</h3><p>POST方法起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被发送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。图3-10显示了一个用POST方法发起HTTP请求————向服务器发送表单数据————客户端  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181900855?method=download&amp;inline=true&amp;version=1&amp;shareToken=A408EA5C51A04EBF9D54D69F3D1E3AC1" alt="image"></p></blockquote><h3 id="5-TRACE"><a href="#5-TRACE" class="headerlink" title="5.TRACE"></a>5.TRACE</h3><p>客户端发起请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p><blockquote><p>TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过（参见原图3-11）。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181906076?method=download&amp;inline=true&amp;version=1&amp;shareToken=79EC26A79BA84E338447C5557A0F4E8E" alt="image"><br>TRACE并不提供区分方法的机制，通常，应用程序会自行决定对TRACE请求的处理方法。TRACE请求中不能带有实体的主体部分。TRACE响应的实体部分包含了响应服务器收到的请求的精确副本。</p></blockquote><h3 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6.OPTIONS"></a>6.OPTIONS</h3><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊的资源支持哪些方法。这为客户端提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。图3-12显示了一个使用OPTIONS方法的请求。  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906405?method=download&amp;inline=true&amp;version=1&amp;shareToken=87D44518564F4A329B683B596DA0BDB9" alt="image"></p></blockquote><h3 id="7-DELETE"><a href="#7-DELETE" class="headerlink" title="7.DELETE"></a>7.DELETE</h3><p>顾名思义，DELETE方法所做的事情就是请求服务器删除请求URL所制定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。图3-13显示了一个DELETE方法的实例。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906607?method=download&amp;inline=true&amp;version=1&amp;shareToken=121689B67692465D9FBA44CD97BFF58B" alt="image"></p></blockquote><h3 id="8-扩展方法"><a href="#8-扩展方法" class="headerlink" title="8.扩展方法"></a>8.扩展方法</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906763?method=download&amp;inline=true&amp;version=1&amp;shareToken=E629EB2E0B0146D4A20CB3EE668F5A30" alt="image"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP学习笔记二&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://blog.husen.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="http://blog.husen.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP概述</title>
    <link href="http://blog.husen.xyz/2018/01/09/HTTP%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.husen.xyz/2018/01/09/HTTP概述/</id>
    <published>2018-01-09T09:09:54.000Z</published>
    <updated>2018-01-09T09:16:41.156Z</updated>
    
    <content type="html"><![CDATA[<p>Web浏览器、服务器和相关的Web应用程序都是通过HTTP相互通信的。HTTP是现代全球英特网中使用的公共语言。<br><a id="more"></a></p><p>1.1 HTTP使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱</p><p>1.2 Web内容都是存储在Web服务器上的。Web服务器所使用的是HTTP协议，因此经常会被称为HTTP服务器。这些HTTP服务器储存了因特网的数据，如果HTTP客户端发出请求的话，它们会提供数据。</p><p>1.3 Web服务器是Web资源的宿主。Web资源是Web内容的源头。资源分为静态资源和动态资源。</p><p>1.3.1 媒体类型：Web服务器会为所有HTTP对象数据附加一个MIME类型。当Web浏览器从服务器中取回一个对象的时候，会去查看相关的MIME类型，看看它是否知道应该如何处理这个对象。</p><p>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</p><ul><li>HTML格式的文本文档由text/html类型来标记。</li><li>普通的ASCII文本文档由text/plain类型来标记。</li><li>JPEG版本的图片为image/jpeg类型。</li><li>GIF格式的图片为image/gif类型。</li><li>Apple的QuickTime电影为video/quicktime类型。</li><li>微软的PowerPoint演示文件为application/vnd.ms-powerpoint类型。</li></ul><p>常见的MIME类型有几百个，实验性或用途有限的MIME类型则更多。《HTTP权威指南》附录D提供了一个非常完整的MIME类型列表</p><p>1.3.2 URL：大部分URL都遵循一种标准格式，这种格式包含了三个部分，在世界范围内唯一标识并定位信息资源。</p><ul><li>URL第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是HTTP协议（<a href="http://）。" target="_blank" rel="noopener">http://）。</a></li><li>第二部分给出了服务器的因特网地址（比如，www.baidu.com）。</li><li>其余部分指定了Web服务器上的某个资源（比如,/imags/xxx.gif）。</li></ul><p>1.3.3 URN：URL的第二种形式就是统一资源名。URN是作为特定内容的唯一名称使用的，与目前资源所在地无关。</p><p>1.4 事务：一个HTTP事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的。</p><p>1.4.1 方法：HTTP支持几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法告诉服务器执行什么动作。一些常见的HTTP方法：</p><ul><li>GET 从服务器向客户端发送命名资源</li><li>PUT 将来自客户端的数据存储到一个命名的服务器资源中去</li><li>DELETE 从服务器中删除命名资源</li><li>POST 将客户端数据发送到一个服务器网关应用程序</li><li>HEAD 仅发送命名资源响应中的HTTP头部</li></ul><p>1.4.2 状态码：每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者需要采取其他动作。几种常见的状态码：</p><ul><li>200      OK，文档正确返回</li><li>302      Redirect（重定向），到其他地方去获取资源</li><li>404      Not Found（没找到），无法找到这个资源</li></ul><p>1.4.3 Web页面中可以包含多个对象：应用程序完成一项任务时通常会发布多个HTTP事务，就是当获取一个丰富的Web页面的时候。浏览器会执行一个事务来获取描述页面布局的HTML“框架”，然后发布另外的HTTP事务来获取每个嵌入式的图片、图像面板、java小程序等。这些资源甚至可能位于不同的服务器上。</p><p>1.5 后面再详讲</p><p>1.6 连接：HTTP协议使用TCP（传输控制协议）来传输其报文数据，在HTTP客户端口号在客户端和服务器之间建立一条TCP/IP连接。TCP使用IP地址和端口号来建立连接。</p><p>1.7 协议版本</p><p>1.8 Web的结构组件</p><ul><li>（1）代理：HTTP代理服务器，这是Web安全、应用集成以及性能优化的重要组成模块。位于客户端和服务器之间，接受所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。出于安全考虑，通常会将代理作为转发所有Web流量的可信用中间节点使用。代理还可以对请求和响应进行过滤。</li><li>（2）缓存：Web缓存（Web cache）或代理缓存（Proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</li><li>（3）网关：网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。例如，一个HTTP/FTP网关会通过HTTP请求接收对FTP URI的请求，单但通过FTP协议来获取文档。</li><li>（4）隧道：隧道（tunnel）是建立起来后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。</li><li>（5）Agent代理：用户Agent代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。</li></ul>]]></content>
    
    <summary type="html">
    
      《HTTP权威指南》第一章HTTP概述
    
    </summary>
    
      <category term="网络协议" scheme="http://blog.husen.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="http://blog.husen.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列（一）:Detailed Introduction 详细介绍</title>
    <link href="http://blog.husen.xyz/2018/01/03/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-Detailed-Introduction-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.husen.xyz/2018/01/03/RabbitMQ消息队列（一）-Detailed-Introduction-详细介绍/</id>
    <published>2018-01-03T14:15:57.000Z</published>
    <updated>2018-01-03T14:31:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。<br>2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。<br>3、RabbitMQ的官网是<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a><br><a id="more"></a></p><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><blockquote><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： </p><ul><li>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据以如何方式丢失？</li><li>2）如何降低发送者和接收者的耦合度？</li><li>3）如何让Priority高的接收者先接到数据？</li><li>4）如何做到load balance？有效均衡接收者的负载？</li><li>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter？</li><li>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</li><li>7）如何保证接收者接收到了完整，正确的数据？<br><strong>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。</strong></li></ul></blockquote><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><blockquote><p><strong>成为系统架构可能不太合适，可能叫应用场景的系统架构更合适。</strong><br><img src="http://img.blog.csdn.net/20140220173559828" alt="cmd-markdown-logo"><br>这个系统架构图版权属于sunjun041640。<br>RabbitMQ Server： 也叫broker server，它不是运送食物的卡车，而是一种传输服务。原话是RabbitMQisn’t a food truck, it’s a delivery service. 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。但是这个保证也不是100%的保证，但是对于普通的应用来说这已经足够了。当然对于商业系统来说，可以再做一层数据一致性的guard，就可以彻底保证系统的一致性了。<br>    Client A &amp; B： 也叫Producer，数据的发送方。createmessages and publish (send) them to a broker server (RabbitMQ).一个Message有两个部分：<strong>payload（有效载荷）和label（标签）</strong>。payload顾名思义就是传输的数据。label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer。AMQP仅仅描述了label，而RabbitMQ决定了如何使用这个label的规则。<br>    Client 1，2，3：也叫Consumer，数据的接收方。Consumersattach to a broker server (RabbitMQ) and subscribe to a queue。把queue比作是一个有名字的邮箱。当有Message到达某个邮箱后，RabbitMQ把它发送给它的某个订阅者即Consumer。当然可能会把同一个Message发送给很多的Consumer。在这个Message中，只有payload，label已经被删掉了。对于Consumer来说，它是不知道谁发送的这个信息的。就是协议本身不支持。但是当然了如果Producer发送的payload包含了Producer的信息就另当别论了。<br>     对于一个数据从Producer到Consumer的正确传递，还有三个概念需要明确<strong>：exchanges, queues and bindings</strong>。<br>        <strong>1、Exchanges are where producers publish their messages：Exchanges是生产者发布消息的地方</strong><br>        <strong>2、Queuesare where the messages end up and are received by consumers：Queuesare才是消息最终被消费者接受的地方</strong><br>        <strong>3、Bindings are how the messages get routed from the exchange to particular queues：绑定是消息从Exchange路由到特定Queuesare的方式</strong><br>   还有几个概念是上述图中没有标明的，那就是Connection（连接），Channel（通道，频道）。<br>   Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。<br>   Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。<br>    那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。有实验表明，1s的时间可以Publish10K的数据包。当然对于不同的硬件环境，不同的数据包大小这个数据肯定不一样，但是我只想说明，对于普通的Consumer或者Producer来说，这已经足够了。如果不够用，你考虑的应该是如何细化split你的设计。</p></blockquote><h2 id="三、进一步的细节阐明"><a href="#三、进一步的细节阐明" class="headerlink" title="三、进一步的细节阐明"></a>三、进一步的细节阐明</h2><blockquote><p><strong>使用ack确认Message的正确传递</strong><br> 默认情况下，如果Message已经被某个Consumer正确的接收到了，那么该Message就会被从queue中移除。当然也可以让同一个Message发送到很多的Consumer。如果一个queue没被任何的Consumer Subscribe（订阅），那么，如果这个queue有数据到达，那么这个数据会被cache，不会被丢弃。当有Consumer时，这个数据会被立即发送到这个Consumer，这个数据被Consumer正确收到时，这个数据就被从queue中删除。<br>    那么什么是正确收到呢？通过ack。每个Message都要被acknowledged（确认，ack）。我们可以显示的在程序中去ack，也可以自动的ack。如果有数据没有被ack，那么：<br>RabbitMQ Server会把这个信息发送到下一个Consumer。<br>如果这个app有bug，忘记了ack，那么RabbitMQ Server不会再发送数据给它，因为Server认为这个Consumer处理能力有限。<br>而且ack的机制可以起到限流的作用（Benefitto throttling）：在Consumer处理完成数据后发送ack，甚至在额外的延时后发送ack，将有效的balance Consumer的load。<br>   当然对于实际的例子，比如我们可能会对某些数据进行merge，比如merge 4s内的数据，然后sleep 4s后再获取数据。特别是在监听系统的state，我们不希望所有的state实时的传递上去，而是希望有一定的延时。这样可以减少某些IO，而且终端用户也不会感觉到。<br><strong>Reject a message</strong><br>有两种方式，第一种的Reject可以让RabbitMQ Server将该Message 发送到下一个Consumer。第二种是从queue中立即删除该Message。<br><strong>Creating a queue</strong><br> Consumer和Procuder都可以通过 queue.declare 创建queue。对于某个Channel来说，Consumer不能declare一个queue，却订阅其他的queue。当然也可以创建私有的queue。这样只有app本身才可以使用这个queue。queue也可以自动删除，被标为auto-delete的queue在最后一个Consumer unsubscribe后就会被自动删除。那么如果是创建一个已经存在的queue呢？那么不会有任何的影响。需要注意的是没有任何的影响，也就是说第二次创建如果参数和第一次不一样，那么该操作虽然成功，但是queue的属性并不会被修改。<br>    那么谁应该负责创建这个queue呢？是Consumer，还是Producer？<br>如果queue不存在，当然Consumer不会得到任何的Message。但是如果queue不存在，那么Producer Publish的Message会被丢弃。所以，为了数据不丢失，Consumer和Producer都try to create the queue！反正不管怎么样，这个接口都不会出问题。<br>   queue对load balance的处理是完美的。对于多个Consumer来说，RabbitMQ 使用循环的方式（round-robin）的方式均衡的发送给不同的Consumer。</p></blockquote><h2 id="四、Exchanges"><a href="#四、Exchanges" class="headerlink" title="四、Exchanges"></a>四、Exchanges</h2><blockquote><p>从架构图可以看出，Procuder Publish的Message进入了Exchange。接着通过“routing keys”， RabbitMQ会找到应该把这个Message放到哪个queue里。queue也是通过这个routing keys来做的绑定。<br>有三种类型的Exchanges：direct,fanout,topic。每个实现了不同的路由算法（routing algorithm）。 </p><ul><li>Direct exchange: 如果 routing key 匹配, 那么Message就会被传递到相应的queue中。其实在queue创建时，它会自动的以queue的名字作为routing key来绑定那个exchange。</li><li>Fanout exchange: 会向响应的queue广播。</li><li>Topic exchange: 对key进行模式匹配，比如ab<em>可以传递到所有ab</em>的queue。</li></ul></blockquote><h2 id="五、Virtual-hosts"><a href="#五、Virtual-hosts" class="headerlink" title="五、Virtual hosts"></a>五、Virtual hosts</h2><blockquote><p>每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bings rule等等。这保证了你可以在多个不同的application中使用RabbitMQ。<br>   接下来我会使用Python来说明RabbitMQ的使用方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。&lt;br&gt;2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。&lt;br&gt;3、RabbitMQ的官网是&lt;a href=&quot;http://www.rabbitmq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.rabbitmq.com&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Advanced Message Queue" scheme="http://blog.husen.xyz/categories/Advanced-Message-Queue/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.husen.xyz/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis keys 命令</title>
    <link href="http://blog.husen.xyz/2017/12/24/Redis-keys-%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.husen.xyz/2017/12/24/Redis-keys-命令/</id>
    <published>2017-12-24T07:25:43.000Z</published>
    <updated>2017-12-24T07:46:42.244Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 键命令用于管理 redis 的键<br><a id="more"></a><br>假如在Redis中有个键值对：username=admin</p><h4 id="该命令用于在-key-存在时删除-key"><a href="#该命令用于在-key-存在时删除-key" class="headerlink" title="该命令用于在 key 存在时删除 key"></a>该命令用于在 key 存在时删除 key</h4><blockquote><p>del key<br>  例如：del username<br>  当username确实存在并成功删除后返回(integer)1<br>  如果username不存在则返回(integer)0</p><h4 id="序列化给定-key-，并返回被序列化的值"><a href="#序列化给定-key-，并返回被序列化的值" class="headerlink" title="序列化给定 key ，并返回被序列化的值"></a>序列化给定 key ，并返回被序列化的值</h4><p>dump key<br>  例如：dump username</p><h4 id="检查给定-key-是否存在"><a href="#检查给定-key-是否存在" class="headerlink" title="检查给定 key 是否存在"></a>检查给定 key 是否存在</h4><p>exists key<br>  例如：exists username<br>  如果存在返回(integer)1<br>  否则：返回(integer)0</p><h4 id="为给定-key-设置过期时间，以秒来记"><a href="#为给定-key-设置过期时间，以秒来记" class="headerlink" title="为给定 key 设置过期时间，以秒来记"></a>为给定 key 设置过期时间，以秒来记</h4><p>expire key seconds<br>  例如：expire username 60</p><h4 id="expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp"><a href="#expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp" class="headerlink" title="expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)"></a>expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)</h4><p>expireat key timestamp</p><h4 id="设置-key-的过期时间以毫秒计"><a href="#设置-key-的过期时间以毫秒计" class="headerlink" title="设置 key 的过期时间以毫秒计"></a>设置 key 的过期时间以毫秒计</h4><p>pexpire key millseconds<br>  例如pexpire username 60000</p><h4 id="设置-key-过期时间的时间戳-unix-timestamp-以毫秒计"><a href="#设置-key-过期时间的时间戳-unix-timestamp-以毫秒计" class="headerlink" title="设置 key 过期时间的时间戳(unix timestamp) 以毫秒计"></a>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</h4><p>pexpireat key millseconds-timestamp</p><h4 id="查找所有符合给定模式-pattern-的-key"><a href="#查找所有符合给定模式-pattern-的-key" class="headerlink" title="查找所有符合给定模式( pattern)的 key"></a>查找所有符合给定模式( pattern)的 key</h4><p>keys pattern<br>  例如：keys * 查找所有的key</p><h4 id="将当前数据库的-key-移动到给定的数据库-db-当中"><a href="#将当前数据库的-key-移动到给定的数据库-db-当中" class="headerlink" title="将当前数据库的 key 移动到给定的数据库 db 当中"></a>将当前数据库的 key 移动到给定的数据库 db 当中</h4><p>move key db<br>  redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。假如我们想把username移动到索引为1的数据库，则<br>  move username 1<br>  这个时候再在当前0数据库下exists username 将会返回0<br>  我们可以通过select 1切换到1数据库，再输入exists username 则会返回1</p><h4 id="移除-key-的过期时间，key-将持久保持"><a href="#移除-key-的过期时间，key-将持久保持" class="headerlink" title="移除 key 的过期时间，key 将持久保持"></a>移除 key 的过期时间，key 将持久保持</h4><p>persist key<br>  如果key已经是持久的就会返回(integer)0</p><h4 id="以毫秒为单位返回-key-的剩余的过期时间"><a href="#以毫秒为单位返回-key-的剩余的过期时间" class="headerlink" title="以毫秒为单位返回 key 的剩余的过期时间"></a>以毫秒为单位返回 key 的剩余的过期时间</h4><p>pttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live"><a href="#以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live" class="headerlink" title="以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)"></a>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</h4><p>ttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="从当前数据库中随机返回一个-key"><a href="#从当前数据库中随机返回一个-key" class="headerlink" title="从当前数据库中随机返回一个 key"></a>从当前数据库中随机返回一个 key</h4><p>randomkey</p><h4 id="修改-key-的名称"><a href="#修改-key-的名称" class="headerlink" title="修改 key 的名称"></a>修改 key 的名称</h4><p>rename key newkey<br>  当newkey存在的时候，会将当前key的值覆盖到newkey的值</p><h4 id="仅当-newkey-不存在时，将-key-改名为-newkey"><a href="#仅当-newkey-不存在时，将-key-改名为-newkey" class="headerlink" title="仅当 newkey 不存在时，将 key 改名为 newkey"></a>仅当 newkey 不存在时，将 key 改名为 newkey</h4><p>renamenx key newkey<br>  当newkey存在的时候将会返回0</p><h4 id="返回-key-所储存的值的类型"><a href="#返回-key-所储存的值的类型" class="headerlink" title="返回 key 所储存的值的类型"></a>返回 key 所储存的值的类型</h4><p>type key<br>  例如：type username 返回string类型</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 键命令用于管理 redis 的键&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.husen.xyz/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.husen.xyz/tags/Redis/"/>
    
  </entry>
  
</feed>
