<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Husen&#39;Blog</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.husen.xyz/"/>
  <updated>2018-01-03T14:31:06.629Z</updated>
  <id>http://blog.husen.xyz/</id>
  
  <author>
    <name>可爱的小森森^_^</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ消息队列（一）:Detailed Introduction 详细介绍</title>
    <link href="http://blog.husen.xyz/2018/01/03/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-Detailed-Introduction-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.husen.xyz/2018/01/03/RabbitMQ消息队列（一）-Detailed-Introduction-详细介绍/</id>
    <published>2018-01-03T14:15:57.000Z</published>
    <updated>2018-01-03T14:31:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。<br>2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。<br>3、RabbitMQ的官网是<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a><br><a id="more"></a></p><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><blockquote><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： </p><ul><li>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据以如何方式丢失？</li><li>2）如何降低发送者和接收者的耦合度？</li><li>3）如何让Priority高的接收者先接到数据？</li><li>4）如何做到load balance？有效均衡接收者的负载？</li><li>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter？</li><li>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</li><li>7）如何保证接收者接收到了完整，正确的数据？<br><strong>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。</strong></li></ul></blockquote><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><blockquote><p><strong>成为系统架构可能不太合适，可能叫应用场景的系统架构更合适。</strong><br><img src="http://img.blog.csdn.net/20140220173559828" alt="cmd-markdown-logo"><br>这个系统架构图版权属于sunjun041640。<br>RabbitMQ Server： 也叫broker server，它不是运送食物的卡车，而是一种传输服务。原话是RabbitMQisn’t a food truck, it’s a delivery service. 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。但是这个保证也不是100%的保证，但是对于普通的应用来说这已经足够了。当然对于商业系统来说，可以再做一层数据一致性的guard，就可以彻底保证系统的一致性了。<br>    Client A &amp; B： 也叫Producer，数据的发送方。createmessages and publish (send) them to a broker server (RabbitMQ).一个Message有两个部分：<strong>payload（有效载荷）和label（标签）</strong>。payload顾名思义就是传输的数据。label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer。AMQP仅仅描述了label，而RabbitMQ决定了如何使用这个label的规则。<br>    Client 1，2，3：也叫Consumer，数据的接收方。Consumersattach to a broker server (RabbitMQ) and subscribe to a queue。把queue比作是一个有名字的邮箱。当有Message到达某个邮箱后，RabbitMQ把它发送给它的某个订阅者即Consumer。当然可能会把同一个Message发送给很多的Consumer。在这个Message中，只有payload，label已经被删掉了。对于Consumer来说，它是不知道谁发送的这个信息的。就是协议本身不支持。但是当然了如果Producer发送的payload包含了Producer的信息就另当别论了。<br>     对于一个数据从Producer到Consumer的正确传递，还有三个概念需要明确<strong>：exchanges, queues and bindings</strong>。<br>        <strong>1、Exchanges are where producers publish their messages：Exchanges是生产者发布消息的地方</strong><br>        <strong>2、Queuesare where the messages end up and are received by consumers：Queuesare才是消息最终被消费者接受的地方</strong><br>        <strong>3、Bindings are how the messages get routed from the exchange to particular queues：绑定是消息从Exchange路由到特定Queuesare的方式</strong><br>   还有几个概念是上述图中没有标明的，那就是Connection（连接），Channel（通道，频道）。<br>   Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。<br>   Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。<br>    那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。有实验表明，1s的时间可以Publish10K的数据包。当然对于不同的硬件环境，不同的数据包大小这个数据肯定不一样，但是我只想说明，对于普通的Consumer或者Producer来说，这已经足够了。如果不够用，你考虑的应该是如何细化split你的设计。</p></blockquote><h2 id="三、进一步的细节阐明"><a href="#三、进一步的细节阐明" class="headerlink" title="三、进一步的细节阐明"></a>三、进一步的细节阐明</h2><blockquote><p><strong>使用ack确认Message的正确传递</strong><br> 默认情况下，如果Message已经被某个Consumer正确的接收到了，那么该Message就会被从queue中移除。当然也可以让同一个Message发送到很多的Consumer。如果一个queue没被任何的Consumer Subscribe（订阅），那么，如果这个queue有数据到达，那么这个数据会被cache，不会被丢弃。当有Consumer时，这个数据会被立即发送到这个Consumer，这个数据被Consumer正确收到时，这个数据就被从queue中删除。<br>    那么什么是正确收到呢？通过ack。每个Message都要被acknowledged（确认，ack）。我们可以显示的在程序中去ack，也可以自动的ack。如果有数据没有被ack，那么：<br>RabbitMQ Server会把这个信息发送到下一个Consumer。<br>如果这个app有bug，忘记了ack，那么RabbitMQ Server不会再发送数据给它，因为Server认为这个Consumer处理能力有限。<br>而且ack的机制可以起到限流的作用（Benefitto throttling）：在Consumer处理完成数据后发送ack，甚至在额外的延时后发送ack，将有效的balance Consumer的load。<br>   当然对于实际的例子，比如我们可能会对某些数据进行merge，比如merge 4s内的数据，然后sleep 4s后再获取数据。特别是在监听系统的state，我们不希望所有的state实时的传递上去，而是希望有一定的延时。这样可以减少某些IO，而且终端用户也不会感觉到。<br><strong>Reject a message</strong><br>有两种方式，第一种的Reject可以让RabbitMQ Server将该Message 发送到下一个Consumer。第二种是从queue中立即删除该Message。<br><strong>Creating a queue</strong><br> Consumer和Procuder都可以通过 queue.declare 创建queue。对于某个Channel来说，Consumer不能declare一个queue，却订阅其他的queue。当然也可以创建私有的queue。这样只有app本身才可以使用这个queue。queue也可以自动删除，被标为auto-delete的queue在最后一个Consumer unsubscribe后就会被自动删除。那么如果是创建一个已经存在的queue呢？那么不会有任何的影响。需要注意的是没有任何的影响，也就是说第二次创建如果参数和第一次不一样，那么该操作虽然成功，但是queue的属性并不会被修改。<br>    那么谁应该负责创建这个queue呢？是Consumer，还是Producer？<br>如果queue不存在，当然Consumer不会得到任何的Message。但是如果queue不存在，那么Producer Publish的Message会被丢弃。所以，为了数据不丢失，Consumer和Producer都try to create the queue！反正不管怎么样，这个接口都不会出问题。<br>   queue对load balance的处理是完美的。对于多个Consumer来说，RabbitMQ 使用循环的方式（round-robin）的方式均衡的发送给不同的Consumer。</p></blockquote><h2 id="四、Exchanges"><a href="#四、Exchanges" class="headerlink" title="四、Exchanges"></a>四、Exchanges</h2><blockquote><p>从架构图可以看出，Procuder Publish的Message进入了Exchange。接着通过“routing keys”， RabbitMQ会找到应该把这个Message放到哪个queue里。queue也是通过这个routing keys来做的绑定。<br>有三种类型的Exchanges：direct,fanout,topic。每个实现了不同的路由算法（routing algorithm）。 </p><ul><li>Direct exchange: 如果 routing key 匹配, 那么Message就会被传递到相应的queue中。其实在queue创建时，它会自动的以queue的名字作为routing key来绑定那个exchange。</li><li>Fanout exchange: 会向响应的queue广播。</li><li>Topic exchange: 对key进行模式匹配，比如ab<em>可以传递到所有ab</em>的queue。</li></ul></blockquote><h2 id="五、Virtual-hosts"><a href="#五、Virtual-hosts" class="headerlink" title="五、Virtual hosts"></a>五、Virtual hosts</h2><blockquote><p>每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bings rule等等。这保证了你可以在多个不同的application中使用RabbitMQ。<br>   接下来我会使用Python来说明RabbitMQ的使用方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。&lt;br&gt;2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。&lt;br&gt;3、RabbitMQ的官网是&lt;a href=&quot;http://www.rabbitmq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.rabbitmq.com&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Advanced Message Queue" scheme="http://blog.husen.xyz/categories/Advanced-Message-Queue/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.husen.xyz/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.husen.xyz/2017/12/24/hello-world/"/>
    <id>http://blog.husen.xyz/2017/12/24/hello-world/</id>
    <published>2017-12-24T07:37:29.040Z</published>
    <updated>2017-12-24T07:37:29.038Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是你的第一篇文章. 查看 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> 会得到更多的信息. 如果你在使用Hexo的过程中遇到任何的问题, 你可以找到这个内容 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一个新的文章"><a href="#创建一个新的文章" class="headerlink" title="创建一个新的文章"></a>创建一个新的文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 发布你的博客</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      这是建站的时候就有的
    
    </summary>
    
      <category term="你好世界" scheme="http://blog.husen.xyz/categories/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="HelloWorld" scheme="http://blog.husen.xyz/tags/HelloWorld/"/>
    
  </entry>
  
  <entry>
    <title>Redis keys 命令</title>
    <link href="http://blog.husen.xyz/2017/12/24/Redis-keys-%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.husen.xyz/2017/12/24/Redis-keys-命令/</id>
    <published>2017-12-24T07:25:43.000Z</published>
    <updated>2017-12-24T07:46:42.244Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 键命令用于管理 redis 的键<br><a id="more"></a><br>假如在Redis中有个键值对：username=admin</p><h4 id="该命令用于在-key-存在时删除-key"><a href="#该命令用于在-key-存在时删除-key" class="headerlink" title="该命令用于在 key 存在时删除 key"></a>该命令用于在 key 存在时删除 key</h4><blockquote><p>del key<br>  例如：del username<br>  当username确实存在并成功删除后返回(integer)1<br>  如果username不存在则返回(integer)0</p><h4 id="序列化给定-key-，并返回被序列化的值"><a href="#序列化给定-key-，并返回被序列化的值" class="headerlink" title="序列化给定 key ，并返回被序列化的值"></a>序列化给定 key ，并返回被序列化的值</h4><p>dump key<br>  例如：dump username</p><h4 id="检查给定-key-是否存在"><a href="#检查给定-key-是否存在" class="headerlink" title="检查给定 key 是否存在"></a>检查给定 key 是否存在</h4><p>exists key<br>  例如：exists username<br>  如果存在返回(integer)1<br>  否则：返回(integer)0</p><h4 id="为给定-key-设置过期时间，以秒来记"><a href="#为给定-key-设置过期时间，以秒来记" class="headerlink" title="为给定 key 设置过期时间，以秒来记"></a>为给定 key 设置过期时间，以秒来记</h4><p>expire key seconds<br>  例如：expire username 60</p><h4 id="expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp"><a href="#expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp" class="headerlink" title="expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)"></a>expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)</h4><p>expireat key timestamp</p><h4 id="设置-key-的过期时间以毫秒计"><a href="#设置-key-的过期时间以毫秒计" class="headerlink" title="设置 key 的过期时间以毫秒计"></a>设置 key 的过期时间以毫秒计</h4><p>pexpire key millseconds<br>  例如pexpire username 60000</p><h4 id="设置-key-过期时间的时间戳-unix-timestamp-以毫秒计"><a href="#设置-key-过期时间的时间戳-unix-timestamp-以毫秒计" class="headerlink" title="设置 key 过期时间的时间戳(unix timestamp) 以毫秒计"></a>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</h4><p>pexpireat key millseconds-timestamp</p><h4 id="查找所有符合给定模式-pattern-的-key"><a href="#查找所有符合给定模式-pattern-的-key" class="headerlink" title="查找所有符合给定模式( pattern)的 key"></a>查找所有符合给定模式( pattern)的 key</h4><p>keys pattern<br>  例如：keys * 查找所有的key</p><h4 id="将当前数据库的-key-移动到给定的数据库-db-当中"><a href="#将当前数据库的-key-移动到给定的数据库-db-当中" class="headerlink" title="将当前数据库的 key 移动到给定的数据库 db 当中"></a>将当前数据库的 key 移动到给定的数据库 db 当中</h4><p>move key db<br>  redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。假如我们想把username移动到索引为1的数据库，则<br>  move username 1<br>  这个时候再在当前0数据库下exists username 将会返回0<br>  我们可以通过select 1切换到1数据库，再输入exists username 则会返回1</p><h4 id="移除-key-的过期时间，key-将持久保持"><a href="#移除-key-的过期时间，key-将持久保持" class="headerlink" title="移除 key 的过期时间，key 将持久保持"></a>移除 key 的过期时间，key 将持久保持</h4><p>persist key<br>  如果key已经是持久的就会返回(integer)0</p><h4 id="以毫秒为单位返回-key-的剩余的过期时间"><a href="#以毫秒为单位返回-key-的剩余的过期时间" class="headerlink" title="以毫秒为单位返回 key 的剩余的过期时间"></a>以毫秒为单位返回 key 的剩余的过期时间</h4><p>pttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live"><a href="#以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live" class="headerlink" title="以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)"></a>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</h4><p>ttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="从当前数据库中随机返回一个-key"><a href="#从当前数据库中随机返回一个-key" class="headerlink" title="从当前数据库中随机返回一个 key"></a>从当前数据库中随机返回一个 key</h4><p>randomkey</p><h4 id="修改-key-的名称"><a href="#修改-key-的名称" class="headerlink" title="修改 key 的名称"></a>修改 key 的名称</h4><p>rename key newkey<br>  当newkey存在的时候，会将当前key的值覆盖到newkey的值</p><h4 id="仅当-newkey-不存在时，将-key-改名为-newkey"><a href="#仅当-newkey-不存在时，将-key-改名为-newkey" class="headerlink" title="仅当 newkey 不存在时，将 key 改名为 newkey"></a>仅当 newkey 不存在时，将 key 改名为 newkey</h4><p>renamenx key newkey<br>  当newkey存在的时候将会返回0</p><h4 id="返回-key-所储存的值的类型"><a href="#返回-key-所储存的值的类型" class="headerlink" title="返回 key 所储存的值的类型"></a>返回 key 所储存的值的类型</h4><p>type key<br>  例如：type username 返回string类型</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 键命令用于管理 redis 的键&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.husen.xyz/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.husen.xyz/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>写作</title>
    <link href="http://blog.husen.xyz/2017/12/21/%E5%86%99%E4%BD%9C/"/>
    <id>http://blog.husen.xyz/2017/12/21/写作/</id>
    <published>2017-12-21T01:30:12.000Z</published>
    <updated>2017-12-23T05:37:47.307Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="写文章" scheme="http://blog.husen.xyz/categories/%E5%86%99%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="linux" scheme="http://blog.husen.xyz/tags/linux/"/>
    
      <category term="nginx" scheme="http://blog.husen.xyz/tags/nginx/"/>
    
      <category term="hexo" scheme="http://blog.husen.xyz/tags/hexo/"/>
    
      <category term="next" scheme="http://blog.husen.xyz/tags/next/"/>
    
      <category term="github" scheme="http://blog.husen.xyz/tags/github/"/>
    
  </entry>
  
</feed>
