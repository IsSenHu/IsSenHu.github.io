<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Husen&#39;Blog</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.husen.xyz/"/>
  <updated>2018-01-20T09:54:45.124Z</updated>
  <id>http://blog.husen.xyz/</id>
  
  <author>
    <name>可爱的小森森^_^</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git分布式版本控制系统的使用七：Git 标签</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%83%EF%BC%9AGit-%E6%A0%87%E7%AD%BE/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用七：Git-标签/</id>
    <published>2018-01-20T09:53:34.000Z</published>
    <updated>2018-01-20T09:54:45.124Z</updated>
    
    <content type="html"><![CDATA[<p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。<br><a id="more"></a><br>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。<br>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。  </p><blockquote><p>git tag -a v1.0   </p></blockquote><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。<br>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-22a5e571257ee2f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。<br>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-b866897262a47d00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如果我们要查看所有标签可以使用以下命令：  </p><blockquote><p>git tag<br><img src="http://upload-images.jianshu.io/upload_images/9692973-b87cddc220849b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>指定标签信息命令：<br>git tag -a <tagname> -m “runoob.com标签”  </tagname></p></blockquote><p>PGP签名标签命令：  </p><blockquote><p>git tag -s <tagname> -m “runoob.com标签”<br>删除标签的命令：<br>git tag -d  </tagname></p></blockquote><p>查看此版本所修改的内容:<br><img src="http://upload-images.jianshu.io/upload_images/9692973-04d5c87e922d4e74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用六：Git 查看提交历史</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%85%AD%EF%BC%9AGit-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用六：Git-查看提交历史/</id>
    <published>2018-01-20T09:52:30.000Z</published>
    <updated>2018-01-20T09:53:13.458Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-commit-history.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-commit-history.html</a><br><a id="more"></a>  </p><h3 id="一、git-log"><a href="#一、git-log" class="headerlink" title="一、git log"></a>一、git log</h3><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。<br>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-04d575ed4b93f5f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="二、–oneline"><a href="#二、–oneline" class="headerlink" title="二、–oneline"></a>二、–oneline</h3><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-c9e8ea5804c8be4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这告诉我们的是，此项目的开发历史。<br>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项。  </p><h3 id="三、–oneline-–graph"><a href="#三、–oneline-–graph" class="headerlink" title="三、–oneline –graph"></a>三、–oneline –graph</h3><p><img src="http://upload-images.jianshu.io/upload_images/9692973-f961100997641fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。  </p><h3 id="四、–reverse"><a href="#四、–reverse" class="headerlink" title="四、–reverse"></a>四、–reverse</h3><p>你也可以用 ‘–reverse’参数来逆向显示所有日志。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-f9c88c3b582c82c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="五、git-log-–author"><a href="#五、git-log-–author" class="headerlink" title="五、git log –author"></a>五、git log –author</h3><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 issenhu 提交的部分：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-8b4cc4abf6224f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="六、–since-和-–before、–until-和-–after"><a href="#六、–since-和-–before、–until-和-–after" class="headerlink" title="六、–since 和 –before、–until 和 –after"></a>六、–since 和 –before、–until 和 –after</h3><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。<br>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-7f65a638301338fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-commit-history.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-commit-history.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用五：Git 分支管理</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%94%EF%BC%9AGit-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用五：Git-分支管理/</id>
    <published>2018-01-20T09:50:59.000Z</published>
    <updated>2018-01-20T09:52:08.439Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-branch.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-branch.html</a><br>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<br>有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。<br><a id="more"></a><br>创建分支命令：  </p><blockquote><p>git branch (branchname)  </p></blockquote><p>切换分支命令:  </p><blockquote><p>git checkout (branchname)  </p></blockquote><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。<br>合并分支命令:  </p><blockquote><p>git merge   </p></blockquote><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。  </p><h3 id="一、列出分支"><a href="#一、列出分支" class="headerlink" title="一、列出分支"></a>一、列出分支</h3><p>列出分支基本命令：  </p><blockquote><p>git branch  </p></blockquote><p>没有参数时，git branch 会列出你在本地的分支。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-a6692e630438afdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。<br>当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。<br>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-b3de9c1c083aa960.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在我们可以看到，有了一个新分支 mytest。<br>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了”testing”分支，Git 将还原你的工作目录到你创建分支时候的样子<br>接下来我们将演示如何切换分支，我们用 <strong>git checkout (branch)</strong> 切换到我们要修改的分支。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-f5fe0b9433f1e13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>当我们切换到”testing”分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.jsp文件又出现了。切换回”master”分支的时候，它们有重新出现了。<br><img src="当我们切换到&quot;testing&quot;分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.php文件又出现了。切换回&quot;master&quot;分支的时候，它们有重新出现了。" alt="image"><br>我们也可以使用 <strong>git checkout -b (branchname)</strong> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-ee8f2dd04d5e208e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。<br>使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。  </p><h3 id="二、删除分支"><a href="#二、删除分支" class="headerlink" title="二、删除分支"></a>二、删除分支</h3><p>删除分支命令：  </p><blockquote><p>git branch -d (branchname)<br>例如我们要删除”newtest”分支：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-6bf6a4f5ac030c9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="三、分支合并"><a href="#三、分支合并" class="headerlink" title="三、分支合并"></a>三、分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去，要提交：<br>git merge  </p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9692973-afd63c89afecaa70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="四、合并冲突"><a href="#四、合并冲突" class="headerlink" title="四、合并冲突"></a>四、合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-9888ddd72d45d4d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>首先，我们创建一个叫做”change_site”的分支，切换过去，我们将内容改为 www.husen.com<br><img src="http://upload-images.jianshu.io/upload_images/9692973-32762bc5e5cadb58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>将修改的内容提交到 “change_site” 分支中。 现在，假如切换回 “master” 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-5308c2816fa9ce01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-d54cd701d33f12c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-a746ba03f3159e13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决<br><img src="http://upload-images.jianshu.io/upload_images/9692973-6346444026bd1515.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在我们成功解决了合并中的冲突，并提交了结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-branch.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-branch.html&lt;/a&gt;&lt;br&gt;几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。&lt;br&gt;有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用四：Git 基本操作</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9B%9B%EF%BC%9AGit-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用四：Git-基本操作/</id>
    <published>2018-01-20T09:49:12.000Z</published>
    <updated>2018-01-20T09:50:46.407Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-basic-operations.html</a><br>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目快照的命令作介绍。<br><a id="more"></a>  </p><h3 id="一、获取与创建项目命令"><a href="#一、获取与创建项目命令" class="headerlink" title="一、获取与创建项目命令"></a>一、获取与创建项目命令</h3><p><strong>git init、git clone</strong>上篇已经讲过了  </p><h3 id="二、基本快照"><a href="#二、基本快照" class="headerlink" title="二、基本快照"></a>二、基本快照</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。  </p><h4 id="（1）git-add"><a href="#（1）git-add" class="headerlink" title="（1）git add"></a>（1）git add</h4><p>git add 命令可将该文件添加到缓存，如我们添加以下两个文件。<br>git status 命令用于查看项目的当前状态：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-8e82fc39e60a399a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>接下来我们执行 git add 命令来添加文件：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-2dd9e736d8c9f5ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。<br>现在我们修改 README 文件：<br>在README中添加”测试”，保存后执行<strong>git status -s</strong><br><img src="http://upload-images.jianshu.io/upload_images/9692973-04a2b50bf4fc2013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们在执行 git add 命令将其添加到缓存中：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-f857f460e9e6fd4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。  </p><h4 id="（2）git-status"><a href="#（2）git-status" class="headerlink" title="（2）git status"></a>（2）git status</h4><p>git status 以查看在你上次提交之后是否有修改。<br>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-6bf5dac7a9fb0a88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h4 id="（3）git-diff"><a href="#（3）git-diff" class="headerlink" title="（3）git diff"></a>（3）git diff</h4><p>执行 git diff 来查看执行 git status 的结果的详细信息。<br>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。  </p><blockquote><ul><li>尚未缓存的改动：<strong>git diff</strong>  </li><li>查看已缓存的改动： <strong>git diff –cached</strong>  </li><li>查看已缓存的与未缓存的所有改动：<strong>git diff HEAD</strong>  </li><li>显示摘要而非整个 diff：<strong>git diff –stat</strong>  </li></ul></blockquote><p>在hello.jsp中输入以下内容：  </p><blockquote><p><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a>  </p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9692973-a34af828cf395667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。<br>接下来我们来查看下 git diff –cached 的执行效果：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-7bfabcf9517b75c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h4 id="（4）git-commit"><a href="#（4）git-commit" class="headerlink" title="（4）git commit"></a>（4）git commit</h4><p>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。<br>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。<br><strong>这里我们在第一章的时候已经配过了</strong><br>接下来我们写入缓存，并提交对 hello.jsp 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-284211c085eba6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在我们已经记录了快照。如果我们再执行 <strong>git status</strong>:<br><img src="http://upload-images.jianshu.io/upload_images/9692973-cfee4f781c1e1ca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。<br>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-0e6ad34be152cde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：  </p><blockquote><p>git commit -a  </p></blockquote><p>我们先修改 hello.jsp 文件为以下内容：  </p><blockquote><p><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a><br><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a>  </p></blockquote><p>再执行以下命令：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-1a552ecb2bfd38dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h4 id="（5）git-reset-HEAD"><a href="#（5）git-reset-HEAD" class="headerlink" title="（5）git reset HEAD"></a>（5）git reset HEAD</h4><p>git reset HEAD 命令用于取消已缓存的内容。<br>我们先改动文件 README 文件，内容如下：  </p><blockquote><p>#测试  </p><p>#test  </p></blockquote><p>hello.jsp 文件修改为：  </p><blockquote><p><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a><br><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a><br><a href="%response.sendRedirect(&quot;http://www.baidu.com&quot;)%">%response.sendRedirect(&quot;http://www.baidu.com&quot;)%</a>  </p></blockquote><p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-121d63932349f456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.jsp 是没有的。<br><img src="http://upload-images.jianshu.io/upload_images/9692973-e8096d5de8a7c26b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>可以看到 hello.jsp 文件的修改并未提交。<br>这时我们可以使用以下命令将 hello.php 的修改提交：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-2387b783ef51deee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>简而言之，执行 <strong>git reset HEAD</strong> 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。  </p><h4 id="（6）git-rm"><a href="#（6）git-rm" class="headerlink" title="（6）git rm"></a>（6）git rm</h4><p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。<br>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作  </p><blockquote><p>git rm <file>  </file></p></blockquote><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f  </p><blockquote><p>git rm -f <file>  </file></p></blockquote><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可  </p><blockquote><p>git rm –cached <file>  </file></p></blockquote><p>如我们删除 hello.jsp文件：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-311c7436a6ae489c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>不从工作区中删除文件：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-bbcf4681a5c11e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：  </p><blockquote><p>git rm –r *   </p></blockquote><p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。  </p><h4 id="（7）git-mv"><a href="#（7）git-mv" class="headerlink" title="（7）git mv"></a>（7）git mv</h4><p>git mv 命令用于移动或重命名一个文件、目录、软连接。<br>我们先把刚移除的 README 添加回来：  </p><blockquote><p>git add README  </p></blockquote><p>然后对其重名:  </p><blockquote><p>git mv README  README.md  </p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9692973-7ea678d93716881f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-basic-operations.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-basic-operations.html&lt;/a&gt;&lt;br&gt;Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目快照的命令作介绍。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用二：Git 工作流程、工作区、暂存区和版本库</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C%EF%BC%9AGit-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用二：Git-工作流程、工作区、暂存区和版本库/</id>
    <published>2018-01-20T09:42:23.000Z</published>
    <updated>2018-01-20T09:48:58.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Git-工作流程"><a href="#一、Git-工作流程" class="headerlink" title="一、Git 工作流程"></a>一、Git 工作流程</h3><p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-workflow.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-workflow.html</a><br>一般的工作流程如下：  </p><blockquote><ol><li>克隆 Git 资源作为工作目录。  </li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。  </li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。<a id="more"></a>  <h4 id="下图展示了-Git-的工作流程："><a href="#下图展示了-Git-的工作流程：" class="headerlink" title="下图展示了 Git 的工作流程："></a>下图展示了 Git 的工作流程：</h4><img src="http://upload-images.jianshu.io/upload_images/9692973-3cfb5d4ebb2fed80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><h3 id="二、Git-工作区、暂存区和版本库"><a href="#二、Git-工作区、暂存区和版本库" class="headerlink" title="二、Git 工作区、暂存区和版本库"></a>二、Git 工作区、暂存区和版本库</h3>参考菜鸟教程  <a href="http://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-workspace-index-repo.html</a><h3 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h3>我们先来理解下Git 工作区、暂存区和版本库概念</li><li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li><li><strong>暂存区</strong>：英文叫stage,或index。一般存放在”.git目录下”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：<br><img src="http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="image">  </li></ol><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的<br>ID被记录在暂存区的文件索引中。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Git-工作流程&quot;&gt;&lt;a href=&quot;#一、Git-工作流程&quot; class=&quot;headerlink&quot; title=&quot;一、Git 工作流程&quot;&gt;&lt;/a&gt;一、Git 工作流程&lt;/h3&gt;&lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-workflow.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-workflow.html&lt;/a&gt;&lt;br&gt;一般的工作流程如下：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;克隆 Git 资源作为工作目录。  &lt;/li&gt;
&lt;li&gt;在克隆的资源上添加或修改文件。&lt;/li&gt;
&lt;li&gt;如果其他人修改了，你可以更新资源。&lt;/li&gt;
&lt;li&gt;在提交前查看修改。&lt;/li&gt;
&lt;li&gt;提交修改。  &lt;/li&gt;
&lt;li&gt;在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用三：Git 创建仓库</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89%EF%BC%9AGit-%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用三：Git-创建仓库/</id>
    <published>2018-01-20T09:41:31.000Z</published>
    <updated>2018-01-20T09:48:38.082Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-create-repository.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-create-repository.html</a><br><a id="more"></a>  </p><h3 id="一、git-init"><a href="#一、git-init" class="headerlink" title="一、git init"></a>一、git init</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。<br>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 <strong>.git</strong> 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 <strong>.git</strong> 目录）。  </p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用当前目录作为Git仓库，我们只需使它初始化。  </p><blockquote><ol><li>在根目录下新建一个gitrepo的文件夹  </li><li>进入新建的文件夹gitrepo执行<strong>git init</strong><br><img src="http://upload-images.jianshu.io/upload_images/9692973-d43276154b70567d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>也可以使用指定的目录作为Git仓库，使用命令：<strong>git init newrepo</strong>  </li></ol></blockquote><p>初始化后，会在 gitrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。<br>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-b7ca4628d549523f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h3 id="三、git-clone"><a href="#三、git-clone" class="headerlink" title="三、git clone"></a>三、git clone</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 svn checkout）。<br>克隆仓库的命令格式为：  </p><blockquote><p>git clone <repo>  </repo></p></blockquote><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：  </p><blockquote><p>git clone <repo> <directory>  </directory></repo></p></blockquote><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><blockquote><p><strong>repo</strong>:Git 仓库。<br><strong>directory</strong>:本地目录。  </p></blockquote><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：  </p><blockquote><p>git clone git://github.com/schacon/grit.git<br><img src="http://upload-images.jianshu.io/upload_images/9692973-36f1591ebc0c63b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p></blockquote><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。<br>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：  </p><blockquote><p>git clone git://github.com/schacon/grit.git mygrit<br><img src="http://upload-images.jianshu.io/upload_images/9692973-fa139dd8b690502d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p></blockquote><h4 id="几种效果等价的git-clone写法："><a href="#几种效果等价的git-clone写法：" class="headerlink" title="几种效果等价的git clone写法："></a>几种效果等价的git clone写法：</h4><blockquote><p>git clone <a href="http://github.com/CosmosHua/locate" target="_blank" rel="noopener">http://github.com/CosmosHua/locate</a> new<br>git clone <a href="http://github.com/CosmosHua/locate.git" target="_blank" rel="noopener">http://github.com/CosmosHua/locate.git</a> new<br>git clone git://github.com/CosmosHua/locate new<br>git clone git://github.com/CosmosHua/locate.git new  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-create-repository.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-create-repository.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统的使用一：Git安装配置</title>
    <link href="http://blog.husen.xyz/2018/01/20/Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80%EF%BC%9AGit%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.husen.xyz/2018/01/20/Git分布式版本控制系统的使用一：Git安装配置/</id>
    <published>2018-01-20T09:35:12.000Z</published>
    <updated>2018-01-20T09:58:21.184Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程  <a href="http://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-install-setup.html</a><br><img src="http://www.runoob.com/wp-content/uploads/2015/02/f7246b600c338744a9591cd7530fd9f9d62aa0f8.png" alt="image"><br><a id="more"></a></p><ol><li>Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。  </li><li>Git 是 Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。  </li><li>Git 与常用的版本控制工具CVS,Subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持。  <h3 id="一、Git-与-SVN-区别"><a href="#一、Git-与-SVN-区别" class="headerlink" title="一、Git 与 SVN 区别"></a>一、Git 与 SVN 区别</h3>GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。Git 与 SVN 区别点：<blockquote><ul><li>1、GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。  </li><li>2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。  </li><li>3、GIT 和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。  </li><li>4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。  </li><li>5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。  </li></ul></blockquote></li></ol><h3 id="二、Git快速入门"><a href="#二、Git快速入门" class="headerlink" title="二、Git快速入门"></a>二、Git快速入门</h3><p><a href="http://git-scm.com/docs" target="_blank" rel="noopener">Git 完整命令手册地址</a><br><a href="http://www.runoob.com/manual/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">PDF 版命令手册</a>  </p><h3 id="三、Git安装配置"><a href="#三、Git安装配置" class="headerlink" title="三、Git安装配置"></a>三、Git安装配置</h3><h4 id="1、Linux平台上安装"><a href="#1、Linux平台上安装" class="headerlink" title="1、Linux平台上安装"></a>1、Linux平台上安装</h4><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：<br>各 Linux 系统可以很简单多使用其安装包管理工具进行安装：</p><h5 id="（1）Debian-Ubuntu"><a href="#（1）Debian-Ubuntu" class="headerlink" title="（1）Debian/Ubuntu"></a>（1）Debian/Ubuntu</h5><p>Debian/Ubuntu Git的安装命令为：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-e754b25986fd764e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h5 id="（2）Centos-RedHat"><a href="#（2）Centos-RedHat" class="headerlink" title="（2）Centos/RedHat"></a>（2）Centos/RedHat</h5><p>Centos/RedHat 安装命令为：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-c110821e9bdf77ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h5 id="（3）Windows-平台上安装"><a href="#（3）Windows-平台上安装" class="headerlink" title="（3）Windows 平台上安装"></a>（3）Windows 平台上安装</h5><p>在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：<br><a href="http://msysgit.github.io/" target="_blank" rel="noopener">安装包下载地址</a><br><img src="http://upload-images.jianshu.io/upload_images/9692973-d2a17725e620ddb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。<br>在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。  </p><h5 id="（4）Git配置"><a href="#（4）Git配置" class="headerlink" title="（4）Git配置"></a>（4）Git配置</h5><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。<br>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  </p><ol><li>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。  </li><li>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。  </li></ol><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。<br>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。  </p><h5 id="（5）用户信息"><a href="#（5）用户信息" class="headerlink" title="（5）用户信息"></a>（5）用户信息</h5><p>配置个人的用户名称和电子邮件地址：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-42454de73e2f6d64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。<br>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。  </p><h5 id="（6）文本编辑器"><a href="#（6）文本编辑器" class="headerlink" title="（6）文本编辑器"></a>（6）文本编辑器</h5><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-75e0004156348c3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><h5 id="（7）差异分析工具"><a href="#（7）差异分析工具" class="headerlink" title="（7）差异分析工具"></a>（7）差异分析工具</h5><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-50c0a4b260a8a72e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。<br>当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。  </p><h5 id="（8）查看配置信息"><a href="#（8）查看配置信息" class="headerlink" title="（8）查看配置信息"></a>（8）查看配置信息</h5><p>要检查已有的配置信息，可以使用 git config –list 命令：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-5387ebf479d3a28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <strong>/etc/gitconfig</strong> 和 <strong>~/.gitconfig</strong>），不过最终 Git 实际采用的是最后一个。<br>这些配置我们也可以在 <strong>~/.gitconfig</strong> 或 <strong>/etc/gitconfig</strong> 看到，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-5f8db0db82bc7fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/9692973-6f5738536fdc3642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：<br><img src="http://upload-images.jianshu.io/upload_images/9692973-6266a023540570ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考菜鸟教程  &lt;a href=&quot;http://www.runoob.com/git/git-install-setup.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.runoob.com/git/git-install-setup.html&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2015/02/f7246b600c338744a9591cd7530fd9f9d62aa0f8.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制工具" scheme="http://blog.husen.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.husen.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习笔记二</title>
    <link href="http://blog.husen.xyz/2018/01/10/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://blog.husen.xyz/2018/01/10/HTTP学习笔记二/</id>
    <published>2018-01-10T09:29:49.000Z</published>
    <updated>2018-01-10T09:50:00.349Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP学习笔记二<br><a id="more"></a></p><h2 id="一、URL"><a href="#一、URL" class="headerlink" title="一、URL"></a>一、URL</h2><p>所有人都对这些名字的标准达成了一致，所以才能方便地共享这座城市的宝藏。你告诉出租车司机把你载到McAllister大街246号，他就知道你的意思了（即使他走的是一条很远的路)</p><h3 id="URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。"><a href="#URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。" class="headerlink" title="URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。"></a>URL就是因特网资源的标准化名称。URL指向每一条电子信息，告诉你它们位于何处，以及如何与之进行交互。</h3><blockquote><p>HTTP URL的路劲组件可以分成若干路径段，每段都可以有自己的参数。比如：<br><a href="http://www.baidu.com;name=sss/index.html;us=22" target="_blank" rel="noopener">http://www.baidu.com;name=sss/index.html;us=22</a></p></blockquote><h3 id="URL结构"><a href="#URL结构" class="headerlink" title="URL结构"></a>URL结构</h3><p>scheme://user:password@host:port/path;params?query#frag</p><ul><li><scheme>方案：访问服务器以获取资源的时候使用哪种协议，默认值无</scheme></li><li><user>用户：某些方案访问资源时需要的用户名，默认值匿名</user></li><li><password>密码：用户名后面可能要包含密码，中间用:分割，默认值E-mail地址</password></li><li><host>主机：资源宿主服务器的主机名或点分Ip地址，默认值无</host></li><li><port>端口：资源宿主服务器正在监听的端口。很多方案都有默认的端口号（HTTP是80）</port></li><li><path></path>路径：服务器上资源的本地名，默认值无</li><li><params>参数：某些方案会用这个组件来指定输入的参数。参数为键=值形式，默认值无</params></li><li><query>查询：某些方案会用这个组件传递参数以激活应用程序。用?将其与URL的其余部分分隔开来，多个用&amp;连接，形式键=值，默认值无</query></li><li><frag>片段：一小片或一部分资源的名字。引用对象时不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其它部分分隔开来，默认值无</frag></li></ul><h2 id="二、报文"><a href="#二、报文" class="headerlink" title="二、报文"></a>二、报文</h2><h3 id="（1）请求报文格式"><a href="#（1）请求报文格式" class="headerlink" title="（1）请求报文格式"></a>（1）请求报文格式</h3><blockquote><p><method> <request-url> <version>   </version></request-url></method></p><headers>  <entity-body></entity-body></headers></blockquote><h3 id="（2）响应报文格式（注意，只有起始行的语法有所不同）"><a href="#（2）响应报文格式（注意，只有起始行的语法有所不同）" class="headerlink" title="（2）响应报文格式（注意，只有起始行的语法有所不同）"></a>（2）响应报文格式（注意，只有起始行的语法有所不同）</h3><blockquote><p><version> <status> <reason-phrase>  </reason-phrase></status></version></p><p><headers>  </headers></p><p>##</p><entity-body></entity-body></blockquote><h3 id="（3）下面对各部分的描述"><a href="#（3）下面对各部分的描述" class="headerlink" title="（3）下面对各部分的描述"></a>（3）下面对各部分的描述</h3><blockquote><ul><li>方法（method）：客户端希望服务器对资源执行的动作。  </li><li>请求URL（request-URL）：命名了所请求的资源，或者URL路径组件的完整URL。  </li><li>版本（version）：报文所使用的HTTP版本，其格式看起来是这样：<br>HTTP/<major>.<minor> 其中主要版本号major和次要版本号minor都是整数。  </minor></major></li><li>状态码（status-code）：这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般列表（“成功”，“出错”等）。  </li><li>原因短语（reason-phrase）：数字状态码的可读版本，包含行终止序列之前的所有文本。  </li><li>首部（header）：可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1要求有效请求或响应报文中必须包含特定的首部。  </li><li>实体的主体部分（entity-body）：实体的主体部分包含了一个任意数据组成的数据块。并不是所有的报文都包含了实体的主体部分，有时，报文只以一个CELF结束。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181881739?method=download&amp;inline=true&amp;version=1&amp;shareToken=899BE9718DEE4A0AB9ECFF1B55A77867" alt="image"></li></ul></blockquote><h2 id="三、状态码"><a href="#三、状态码" class="headerlink" title="三、状态码"></a>三、状态码</h2><p>方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181881798?method=download&amp;inline=true&amp;version=1&amp;shareToken=B3C0BB6F90A7493BBBB5F9DBA1F055D4" alt="image"></p><h3 id="1、100-199——信息状态码"><a href="#1、100-199——信息状态码" class="headerlink" title="1、100~199——信息状态码"></a>1、100~199——信息状态码</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906830?method=download&amp;inline=true&amp;version=1&amp;shareToken=C30FB2943F134A33ABB7A449EC28C114" alt="image"></p></blockquote><h3 id="2、200-299——成功状态码"><a href="#2、200-299——成功状态码" class="headerlink" title="2、200~299——成功状态码"></a>2、200~299——成功状态码</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912059?method=download&amp;inline=true&amp;version=1&amp;shareToken=B60E8C0B082A45C2A21FEB202A412CA1" alt="image"></p></blockquote><h3 id="3、300-399——重定向状态码"><a href="#3、300-399——重定向状态码" class="headerlink" title="3、300~399——重定向状态码"></a>3、300~399——重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应二不是资源的内容。如果资源已被移走，可以发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪里找到它（见图3-14）。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912367?method=download&amp;inline=true&amp;version=1&amp;shareToken=BAF473E6738F4A08813CA56749727C07" alt="image"></p></blockquote><p>可以通过某些重定向的状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。图3-15显示了一个这样的例子。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181912726?method=download&amp;inline=true&amp;version=1&amp;shareToken=915E96C94531493BA2CD4727A78E43BE" alt="image"><br>表3-8  重定向状态码与原因短语<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181912956?method=download&amp;inline=true&amp;version=1&amp;shareToken=94C7EDD9D1A44014A9E026108DF5BF30" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181912958?method=download&amp;inline=true&amp;version=1&amp;shareToken=FD881807FE814D749DC55526289E41EE" alt="image"></p></blockquote><h3 id="4、400-499——客户端错误状态码"><a href="#4、400-499——客户端错误状态码" class="headerlink" title="4、400~499——客户端错误状态码"></a>4、400~499——客户端错误状态码</h3><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的就是，请求一个不存在的URL。<br>表3-9 客户端错误状态码及原因短语  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916366?method=download&amp;inline=true&amp;version=1&amp;shareToken=B411435FBD7740FBA9935BD629878439" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916429?method=download&amp;inline=true&amp;version=1&amp;shareToken=45C83F8DF83B4334B5B543E714AA504D" alt="image"></p></blockquote><h3 id="5、500-599——服务器错误状态码"><a href="#5、500-599——服务器错误状态码" class="headerlink" title="5、500~599——服务器错误状态码"></a>5、500~599——服务器错误状态码</h3><p>有时客户端发送了一条有效的请求，服务器自身却出错误了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如，某个网关资源出了错。<br>表3-10 服务器错误状态码及原因短语</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916502?method=download&amp;inline=true&amp;version=1&amp;shareToken=45C3DBA7A1F647A9BE57E3D3D28DAE6E" alt="image"></p></blockquote><p>当前的HTTP版本只为每类状态定义了几个代码。随着协议的发展，HTTP规范中会正式地定义更多的状态码。如果收到不认识的状态码，可能是有人将其当作当前协议的扩展定义的。可以根据其所在的范围，将它作为那个类别中的一个普通的成员来处理。</p><h2 id="四、首部分类"><a href="#四、首部分类" class="headerlink" title="四、首部分类"></a>四、首部分类</h2><p>HTTP规范定义了几种首部字段。应用程序也可以随意的发明自己所用的首部</p><ul><li>首部通用<br>既可以出现在请求报文里，也可以出现在响应报文里。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916543?method=download&amp;inline=true&amp;version=1&amp;shareToken=3A3CC3021D454AFAB6F6D7E249CB9439" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916570?method=download&amp;inline=true&amp;version=1&amp;shareToken=7CA0C21E00E7406EB4C1B67A43DF70A3" alt="image"></p></blockquote></li><li>请求首部<br>提供更多有关请求的信息。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916580?method=download&amp;inline=true&amp;version=1&amp;shareToken=E143E0968D4A4DAB913131D87EB38219" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916687?method=download&amp;inline=true&amp;version=1&amp;shareToken=F83E8568D8634F049830202C297527F3" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916714?method=download&amp;inline=true&amp;version=1&amp;shareToken=A890E4C67C6540379A6270820031B3B9" alt="image"></p></blockquote></li><li>响应首部<br>提供更多有关响应的信息。  <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181916749?method=download&amp;inline=true&amp;version=1&amp;shareToken=0AD17F00A44F4E0BAC0FC0FC52C10DF4" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181916794?method=download&amp;inline=true&amp;version=1&amp;shareToken=BF20F488657E463B97572D89FE4C99C9" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181928062?method=download&amp;inline=true&amp;version=1&amp;shareToken=339904B2265D4B2495B049544AF98E10" alt="image"></p></blockquote></li><li>实体首部<br>描述主体的长度和内容，或者资源自身。 <blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181928157?method=download&amp;inline=true&amp;version=1&amp;shareToken=D288999643974C39A26549B690799AAA" alt="image"><br><img src="https://note.youdao.com/yws/api/group/66051437/file/181928177?method=download&amp;inline=true&amp;version=1&amp;shareToken=A4B26EAE18C2444A93B9F62A9B75822E" alt="image"></p></blockquote></li><li>扩展首部<br>规范中没有定义的新首部。<br>每个HTTP首部都有一种简单的语法：名字后面跟着冒号（:），然后跟上可选的空格，再跟上字段值，最后是一个CRLF。</li></ul><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181886729?method=download&amp;inline=true&amp;version=1&amp;shareToken=5EC94415A0AB4F8EAF8C86F94884ED3D" alt="image"></p><h2 id="五、实体的主体部分"><a href="#五、实体的主体部分" class="headerlink" title="五、实体的主体部分"></a>五、实体的主体部分</h2><p>HTTP报文的第三部分是可选的实体部分。实体的主体部分是HTTP报文的负荷。就是HTTP要传输的内容</p><p>HTTP报文可以承载很多类型的数字数据：图片、视频、html文档、软件应用程序、信用卡事务、电子邮件等。</p><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h3><blockquote><p>GET是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1要求服务器实现此方法。图3-7显示了一个例子。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181891000?method=download&amp;inline=true&amp;version=1&amp;shareToken=6BEDCC7EE001499FB503EBB5E64C92C7" alt="image"></p></blockquote><h3 id="2-HEAD"><a href="#2-HEAD" class="headerlink" title="2.HEAD"></a>2.HEAD</h3><blockquote><p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。使用HEAD可以：  </p><ul><li>在不获取资源的情况下了解资源的情况（比如，判断其类型）；  </li><li>通过查看响应中的状态码，看看某个对象是否存在；  </li><li>通过查看首部，测试资源是否被修改了。<br>服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循HTTP/1.1规范，就必须实现HEAD方法。图3-8显示了实际的HEAD方法。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181900403?method=download&amp;inline=true&amp;version=1&amp;shareToken=DA050DD77D8F45A79A7C15CCB0CE6602" alt="image"></li></ul></blockquote><h3 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3.PUT"></a>3.PUT</h3><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档。有些发布系统允许用户创建Web页面，并用PUT直接将其安装到Web服务器上去（参加图3-9）。  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181900491?method=download&amp;inline=true&amp;version=1&amp;shareToken=870C8B5810E34B048F7C30807C14AFD0" alt="image"></p></blockquote><h3 id="4-POST"><a href="#4-POST" class="headerlink" title="4.POST"></a>4.POST</h3><p>POST方法起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被发送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。图3-10显示了一个用POST方法发起HTTP请求————向服务器发送表单数据————客户端  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181900855?method=download&amp;inline=true&amp;version=1&amp;shareToken=A408EA5C51A04EBF9D54D69F3D1E3AC1" alt="image"></p></blockquote><h3 id="5-TRACE"><a href="#5-TRACE" class="headerlink" title="5.TRACE"></a>5.TRACE</h3><p>客户端发起请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p><blockquote><p>TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过（参见原图3-11）。<br><img src="https://note.youdao.com/yws/api/group/66051437/file/181906076?method=download&amp;inline=true&amp;version=1&amp;shareToken=79EC26A79BA84E338447C5557A0F4E8E" alt="image"><br>TRACE并不提供区分方法的机制，通常，应用程序会自行决定对TRACE请求的处理方法。TRACE请求中不能带有实体的主体部分。TRACE响应的实体部分包含了响应服务器收到的请求的精确副本。</p></blockquote><h3 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6.OPTIONS"></a>6.OPTIONS</h3><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊的资源支持哪些方法。这为客户端提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。图3-12显示了一个使用OPTIONS方法的请求。  </p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906405?method=download&amp;inline=true&amp;version=1&amp;shareToken=87D44518564F4A329B683B596DA0BDB9" alt="image"></p></blockquote><h3 id="7-DELETE"><a href="#7-DELETE" class="headerlink" title="7.DELETE"></a>7.DELETE</h3><p>顾名思义，DELETE方法所做的事情就是请求服务器删除请求URL所制定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。图3-13显示了一个DELETE方法的实例。</p><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906607?method=download&amp;inline=true&amp;version=1&amp;shareToken=121689B67692465D9FBA44CD97BFF58B" alt="image"></p></blockquote><h3 id="8-扩展方法"><a href="#8-扩展方法" class="headerlink" title="8.扩展方法"></a>8.扩展方法</h3><blockquote><p><img src="https://note.youdao.com/yws/api/group/66051437/file/181906763?method=download&amp;inline=true&amp;version=1&amp;shareToken=E629EB2E0B0146D4A20CB3EE668F5A30" alt="image"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP学习笔记二&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://blog.husen.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="http://blog.husen.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP概述</title>
    <link href="http://blog.husen.xyz/2018/01/09/HTTP%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.husen.xyz/2018/01/09/HTTP概述/</id>
    <published>2018-01-09T09:09:54.000Z</published>
    <updated>2018-01-09T09:16:41.156Z</updated>
    
    <content type="html"><![CDATA[<p>Web浏览器、服务器和相关的Web应用程序都是通过HTTP相互通信的。HTTP是现代全球英特网中使用的公共语言。<br><a id="more"></a></p><p>1.1 HTTP使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱</p><p>1.2 Web内容都是存储在Web服务器上的。Web服务器所使用的是HTTP协议，因此经常会被称为HTTP服务器。这些HTTP服务器储存了因特网的数据，如果HTTP客户端发出请求的话，它们会提供数据。</p><p>1.3 Web服务器是Web资源的宿主。Web资源是Web内容的源头。资源分为静态资源和动态资源。</p><p>1.3.1 媒体类型：Web服务器会为所有HTTP对象数据附加一个MIME类型。当Web浏览器从服务器中取回一个对象的时候，会去查看相关的MIME类型，看看它是否知道应该如何处理这个对象。</p><p>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</p><ul><li>HTML格式的文本文档由text/html类型来标记。</li><li>普通的ASCII文本文档由text/plain类型来标记。</li><li>JPEG版本的图片为image/jpeg类型。</li><li>GIF格式的图片为image/gif类型。</li><li>Apple的QuickTime电影为video/quicktime类型。</li><li>微软的PowerPoint演示文件为application/vnd.ms-powerpoint类型。</li></ul><p>常见的MIME类型有几百个，实验性或用途有限的MIME类型则更多。《HTTP权威指南》附录D提供了一个非常完整的MIME类型列表</p><p>1.3.2 URL：大部分URL都遵循一种标准格式，这种格式包含了三个部分，在世界范围内唯一标识并定位信息资源。</p><ul><li>URL第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是HTTP协议（<a href="http://）。" target="_blank" rel="noopener">http://）。</a></li><li>第二部分给出了服务器的因特网地址（比如，www.baidu.com）。</li><li>其余部分指定了Web服务器上的某个资源（比如,/imags/xxx.gif）。</li></ul><p>1.3.3 URN：URL的第二种形式就是统一资源名。URN是作为特定内容的唯一名称使用的，与目前资源所在地无关。</p><p>1.4 事务：一个HTTP事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的。</p><p>1.4.1 方法：HTTP支持几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法告诉服务器执行什么动作。一些常见的HTTP方法：</p><ul><li>GET 从服务器向客户端发送命名资源</li><li>PUT 将来自客户端的数据存储到一个命名的服务器资源中去</li><li>DELETE 从服务器中删除命名资源</li><li>POST 将客户端数据发送到一个服务器网关应用程序</li><li>HEAD 仅发送命名资源响应中的HTTP头部</li></ul><p>1.4.2 状态码：每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者需要采取其他动作。几种常见的状态码：</p><ul><li>200      OK，文档正确返回</li><li>302      Redirect（重定向），到其他地方去获取资源</li><li>404      Not Found（没找到），无法找到这个资源</li></ul><p>1.4.3 Web页面中可以包含多个对象：应用程序完成一项任务时通常会发布多个HTTP事务，就是当获取一个丰富的Web页面的时候。浏览器会执行一个事务来获取描述页面布局的HTML“框架”，然后发布另外的HTTP事务来获取每个嵌入式的图片、图像面板、java小程序等。这些资源甚至可能位于不同的服务器上。</p><p>1.5 后面再详讲</p><p>1.6 连接：HTTP协议使用TCP（传输控制协议）来传输其报文数据，在HTTP客户端口号在客户端和服务器之间建立一条TCP/IP连接。TCP使用IP地址和端口号来建立连接。</p><p>1.7 协议版本</p><p>1.8 Web的结构组件</p><ul><li>（1）代理：HTTP代理服务器，这是Web安全、应用集成以及性能优化的重要组成模块。位于客户端和服务器之间，接受所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。出于安全考虑，通常会将代理作为转发所有Web流量的可信用中间节点使用。代理还可以对请求和响应进行过滤。</li><li>（2）缓存：Web缓存（Web cache）或代理缓存（Proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</li><li>（3）网关：网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。例如，一个HTTP/FTP网关会通过HTTP请求接收对FTP URI的请求，单但通过FTP协议来获取文档。</li><li>（4）隧道：隧道（tunnel）是建立起来后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。</li><li>（5）Agent代理：用户Agent代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。</li></ul>]]></content>
    
    <summary type="html">
    
      《HTTP权威指南》第一章HTTP概述
    
    </summary>
    
      <category term="网络协议" scheme="http://blog.husen.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="http://blog.husen.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列（一）:Detailed Introduction 详细介绍</title>
    <link href="http://blog.husen.xyz/2018/01/03/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-Detailed-Introduction-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.husen.xyz/2018/01/03/RabbitMQ消息队列（一）-Detailed-Introduction-详细介绍/</id>
    <published>2018-01-03T14:15:57.000Z</published>
    <updated>2018-01-03T14:31:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。<br>2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。<br>3、RabbitMQ的官网是<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a><br><a id="more"></a></p><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><blockquote><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： </p><ul><li>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据以如何方式丢失？</li><li>2）如何降低发送者和接收者的耦合度？</li><li>3）如何让Priority高的接收者先接到数据？</li><li>4）如何做到load balance？有效均衡接收者的负载？</li><li>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter？</li><li>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</li><li>7）如何保证接收者接收到了完整，正确的数据？<br><strong>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。</strong></li></ul></blockquote><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><blockquote><p><strong>成为系统架构可能不太合适，可能叫应用场景的系统架构更合适。</strong><br><img src="http://img.blog.csdn.net/20140220173559828" alt="cmd-markdown-logo"><br>这个系统架构图版权属于sunjun041640。<br>RabbitMQ Server： 也叫broker server，它不是运送食物的卡车，而是一种传输服务。原话是RabbitMQisn’t a food truck, it’s a delivery service. 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。但是这个保证也不是100%的保证，但是对于普通的应用来说这已经足够了。当然对于商业系统来说，可以再做一层数据一致性的guard，就可以彻底保证系统的一致性了。<br>    Client A &amp; B： 也叫Producer，数据的发送方。createmessages and publish (send) them to a broker server (RabbitMQ).一个Message有两个部分：<strong>payload（有效载荷）和label（标签）</strong>。payload顾名思义就是传输的数据。label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer。AMQP仅仅描述了label，而RabbitMQ决定了如何使用这个label的规则。<br>    Client 1，2，3：也叫Consumer，数据的接收方。Consumersattach to a broker server (RabbitMQ) and subscribe to a queue。把queue比作是一个有名字的邮箱。当有Message到达某个邮箱后，RabbitMQ把它发送给它的某个订阅者即Consumer。当然可能会把同一个Message发送给很多的Consumer。在这个Message中，只有payload，label已经被删掉了。对于Consumer来说，它是不知道谁发送的这个信息的。就是协议本身不支持。但是当然了如果Producer发送的payload包含了Producer的信息就另当别论了。<br>     对于一个数据从Producer到Consumer的正确传递，还有三个概念需要明确<strong>：exchanges, queues and bindings</strong>。<br>        <strong>1、Exchanges are where producers publish their messages：Exchanges是生产者发布消息的地方</strong><br>        <strong>2、Queuesare where the messages end up and are received by consumers：Queuesare才是消息最终被消费者接受的地方</strong><br>        <strong>3、Bindings are how the messages get routed from the exchange to particular queues：绑定是消息从Exchange路由到特定Queuesare的方式</strong><br>   还有几个概念是上述图中没有标明的，那就是Connection（连接），Channel（通道，频道）。<br>   Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。<br>   Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。<br>    那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。有实验表明，1s的时间可以Publish10K的数据包。当然对于不同的硬件环境，不同的数据包大小这个数据肯定不一样，但是我只想说明，对于普通的Consumer或者Producer来说，这已经足够了。如果不够用，你考虑的应该是如何细化split你的设计。</p></blockquote><h2 id="三、进一步的细节阐明"><a href="#三、进一步的细节阐明" class="headerlink" title="三、进一步的细节阐明"></a>三、进一步的细节阐明</h2><blockquote><p><strong>使用ack确认Message的正确传递</strong><br> 默认情况下，如果Message已经被某个Consumer正确的接收到了，那么该Message就会被从queue中移除。当然也可以让同一个Message发送到很多的Consumer。如果一个queue没被任何的Consumer Subscribe（订阅），那么，如果这个queue有数据到达，那么这个数据会被cache，不会被丢弃。当有Consumer时，这个数据会被立即发送到这个Consumer，这个数据被Consumer正确收到时，这个数据就被从queue中删除。<br>    那么什么是正确收到呢？通过ack。每个Message都要被acknowledged（确认，ack）。我们可以显示的在程序中去ack，也可以自动的ack。如果有数据没有被ack，那么：<br>RabbitMQ Server会把这个信息发送到下一个Consumer。<br>如果这个app有bug，忘记了ack，那么RabbitMQ Server不会再发送数据给它，因为Server认为这个Consumer处理能力有限。<br>而且ack的机制可以起到限流的作用（Benefitto throttling）：在Consumer处理完成数据后发送ack，甚至在额外的延时后发送ack，将有效的balance Consumer的load。<br>   当然对于实际的例子，比如我们可能会对某些数据进行merge，比如merge 4s内的数据，然后sleep 4s后再获取数据。特别是在监听系统的state，我们不希望所有的state实时的传递上去，而是希望有一定的延时。这样可以减少某些IO，而且终端用户也不会感觉到。<br><strong>Reject a message</strong><br>有两种方式，第一种的Reject可以让RabbitMQ Server将该Message 发送到下一个Consumer。第二种是从queue中立即删除该Message。<br><strong>Creating a queue</strong><br> Consumer和Procuder都可以通过 queue.declare 创建queue。对于某个Channel来说，Consumer不能declare一个queue，却订阅其他的queue。当然也可以创建私有的queue。这样只有app本身才可以使用这个queue。queue也可以自动删除，被标为auto-delete的queue在最后一个Consumer unsubscribe后就会被自动删除。那么如果是创建一个已经存在的queue呢？那么不会有任何的影响。需要注意的是没有任何的影响，也就是说第二次创建如果参数和第一次不一样，那么该操作虽然成功，但是queue的属性并不会被修改。<br>    那么谁应该负责创建这个queue呢？是Consumer，还是Producer？<br>如果queue不存在，当然Consumer不会得到任何的Message。但是如果queue不存在，那么Producer Publish的Message会被丢弃。所以，为了数据不丢失，Consumer和Producer都try to create the queue！反正不管怎么样，这个接口都不会出问题。<br>   queue对load balance的处理是完美的。对于多个Consumer来说，RabbitMQ 使用循环的方式（round-robin）的方式均衡的发送给不同的Consumer。</p></blockquote><h2 id="四、Exchanges"><a href="#四、Exchanges" class="headerlink" title="四、Exchanges"></a>四、Exchanges</h2><blockquote><p>从架构图可以看出，Procuder Publish的Message进入了Exchange。接着通过“routing keys”， RabbitMQ会找到应该把这个Message放到哪个queue里。queue也是通过这个routing keys来做的绑定。<br>有三种类型的Exchanges：direct,fanout,topic。每个实现了不同的路由算法（routing algorithm）。 </p><ul><li>Direct exchange: 如果 routing key 匹配, 那么Message就会被传递到相应的queue中。其实在queue创建时，它会自动的以queue的名字作为routing key来绑定那个exchange。</li><li>Fanout exchange: 会向响应的queue广播。</li><li>Topic exchange: 对key进行模式匹配，比如ab<em>可以传递到所有ab</em>的queue。</li></ul></blockquote><h2 id="五、Virtual-hosts"><a href="#五、Virtual-hosts" class="headerlink" title="五、Virtual hosts"></a>五、Virtual hosts</h2><blockquote><p>每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bings rule等等。这保证了你可以在多个不同的application中使用RabbitMQ。<br>   接下来我会使用Python来说明RabbitMQ的使用方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。&lt;br&gt;2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。&lt;br&gt;3、RabbitMQ的官网是&lt;a href=&quot;http://www.rabbitmq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.rabbitmq.com&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Advanced Message Queue" scheme="http://blog.husen.xyz/categories/Advanced-Message-Queue/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.husen.xyz/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis keys 命令</title>
    <link href="http://blog.husen.xyz/2017/12/24/Redis-keys-%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.husen.xyz/2017/12/24/Redis-keys-命令/</id>
    <published>2017-12-24T07:25:43.000Z</published>
    <updated>2017-12-24T07:46:42.244Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 键命令用于管理 redis 的键<br><a id="more"></a><br>假如在Redis中有个键值对：username=admin</p><h4 id="该命令用于在-key-存在时删除-key"><a href="#该命令用于在-key-存在时删除-key" class="headerlink" title="该命令用于在 key 存在时删除 key"></a>该命令用于在 key 存在时删除 key</h4><blockquote><p>del key<br>  例如：del username<br>  当username确实存在并成功删除后返回(integer)1<br>  如果username不存在则返回(integer)0</p><h4 id="序列化给定-key-，并返回被序列化的值"><a href="#序列化给定-key-，并返回被序列化的值" class="headerlink" title="序列化给定 key ，并返回被序列化的值"></a>序列化给定 key ，并返回被序列化的值</h4><p>dump key<br>  例如：dump username</p><h4 id="检查给定-key-是否存在"><a href="#检查给定-key-是否存在" class="headerlink" title="检查给定 key 是否存在"></a>检查给定 key 是否存在</h4><p>exists key<br>  例如：exists username<br>  如果存在返回(integer)1<br>  否则：返回(integer)0</p><h4 id="为给定-key-设置过期时间，以秒来记"><a href="#为给定-key-设置过期时间，以秒来记" class="headerlink" title="为给定 key 设置过期时间，以秒来记"></a>为给定 key 设置过期时间，以秒来记</h4><p>expire key seconds<br>  例如：expire username 60</p><h4 id="expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp"><a href="#expireat-的作用和-expire-类似，都用于为-key-设置过期时间。-不同在于-EXPIREAT-命令接受的时间参数是-UNIX-时间戳-unix-timestamp" class="headerlink" title="expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)"></a>expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)</h4><p>expireat key timestamp</p><h4 id="设置-key-的过期时间以毫秒计"><a href="#设置-key-的过期时间以毫秒计" class="headerlink" title="设置 key 的过期时间以毫秒计"></a>设置 key 的过期时间以毫秒计</h4><p>pexpire key millseconds<br>  例如pexpire username 60000</p><h4 id="设置-key-过期时间的时间戳-unix-timestamp-以毫秒计"><a href="#设置-key-过期时间的时间戳-unix-timestamp-以毫秒计" class="headerlink" title="设置 key 过期时间的时间戳(unix timestamp) 以毫秒计"></a>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</h4><p>pexpireat key millseconds-timestamp</p><h4 id="查找所有符合给定模式-pattern-的-key"><a href="#查找所有符合给定模式-pattern-的-key" class="headerlink" title="查找所有符合给定模式( pattern)的 key"></a>查找所有符合给定模式( pattern)的 key</h4><p>keys pattern<br>  例如：keys * 查找所有的key</p><h4 id="将当前数据库的-key-移动到给定的数据库-db-当中"><a href="#将当前数据库的-key-移动到给定的数据库-db-当中" class="headerlink" title="将当前数据库的 key 移动到给定的数据库 db 当中"></a>将当前数据库的 key 移动到给定的数据库 db 当中</h4><p>move key db<br>  redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。假如我们想把username移动到索引为1的数据库，则<br>  move username 1<br>  这个时候再在当前0数据库下exists username 将会返回0<br>  我们可以通过select 1切换到1数据库，再输入exists username 则会返回1</p><h4 id="移除-key-的过期时间，key-将持久保持"><a href="#移除-key-的过期时间，key-将持久保持" class="headerlink" title="移除 key 的过期时间，key 将持久保持"></a>移除 key 的过期时间，key 将持久保持</h4><p>persist key<br>  如果key已经是持久的就会返回(integer)0</p><h4 id="以毫秒为单位返回-key-的剩余的过期时间"><a href="#以毫秒为单位返回-key-的剩余的过期时间" class="headerlink" title="以毫秒为单位返回 key 的剩余的过期时间"></a>以毫秒为单位返回 key 的剩余的过期时间</h4><p>pttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live"><a href="#以秒为单位，返回给定-key-的剩余生存时间-TTL-time-to-live" class="headerlink" title="以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)"></a>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</h4><p>ttl key<br>  如果key是持久的就会返回(integer)-1</p><h4 id="从当前数据库中随机返回一个-key"><a href="#从当前数据库中随机返回一个-key" class="headerlink" title="从当前数据库中随机返回一个 key"></a>从当前数据库中随机返回一个 key</h4><p>randomkey</p><h4 id="修改-key-的名称"><a href="#修改-key-的名称" class="headerlink" title="修改 key 的名称"></a>修改 key 的名称</h4><p>rename key newkey<br>  当newkey存在的时候，会将当前key的值覆盖到newkey的值</p><h4 id="仅当-newkey-不存在时，将-key-改名为-newkey"><a href="#仅当-newkey-不存在时，将-key-改名为-newkey" class="headerlink" title="仅当 newkey 不存在时，将 key 改名为 newkey"></a>仅当 newkey 不存在时，将 key 改名为 newkey</h4><p>renamenx key newkey<br>  当newkey存在的时候将会返回0</p><h4 id="返回-key-所储存的值的类型"><a href="#返回-key-所储存的值的类型" class="headerlink" title="返回 key 所储存的值的类型"></a>返回 key 所储存的值的类型</h4><p>type key<br>  例如：type username 返回string类型</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 键命令用于管理 redis 的键&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.husen.xyz/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.husen.xyz/tags/Redis/"/>
    
  </entry>
  
</feed>
