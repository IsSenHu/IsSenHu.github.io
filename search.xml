<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP概述]]></title>
    <url>%2F2018%2F01%2F09%2FHTTP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Web浏览器、服务器和相关的Web应用程序都是通过HTTP相互通信的。HTTP是现代全球英特网中使用的公共语言。 1.1 HTTP使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱 1.2 Web内容都是存储在Web服务器上的。Web服务器所使用的是HTTP协议，因此经常会被称为HTTP服务器。这些HTTP服务器储存了因特网的数据，如果HTTP客户端发出请求的话，它们会提供数据。 1.3 Web服务器是Web资源的宿主。Web资源是Web内容的源头。资源分为静态资源和动态资源。 1.3.1 媒体类型：Web服务器会为所有HTTP对象数据附加一个MIME类型。当Web浏览器从服务器中取回一个对象的时候，会去查看相关的MIME类型，看看它是否知道应该如何处理这个对象。 MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。 HTML格式的文本文档由text/html类型来标记。 普通的ASCII文本文档由text/plain类型来标记。 JPEG版本的图片为image/jpeg类型。 GIF格式的图片为image/gif类型。 Apple的QuickTime电影为video/quicktime类型。 微软的PowerPoint演示文件为application/vnd.ms-powerpoint类型。 常见的MIME类型有几百个，实验性或用途有限的MIME类型则更多。《HTTP权威指南》附录D提供了一个非常完整的MIME类型列表 1.3.2 URL：大部分URL都遵循一种标准格式，这种格式包含了三个部分，在世界范围内唯一标识并定位信息资源。 URL第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是HTTP协议（http://）。 第二部分给出了服务器的因特网地址（比如，www.baidu.com）。 其余部分指定了Web服务器上的某个资源（比如,/imags/xxx.gif）。 1.3.3 URN：URL的第二种形式就是统一资源名。URN是作为特定内容的唯一名称使用的，与目前资源所在地无关。 1.4 事务：一个HTTP事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的。 1.4.1 方法：HTTP支持几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法告诉服务器执行什么动作。一些常见的HTTP方法： GET 从服务器向客户端发送命名资源 PUT 将来自客户端的数据存储到一个命名的服务器资源中去 DELETE 从服务器中删除命名资源 POST 将客户端数据发送到一个服务器网关应用程序 HEAD 仅发送命名资源响应中的HTTP头部 1.4.2 状态码：每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者需要采取其他动作。几种常见的状态码： 200 OK，文档正确返回 302 Redirect（重定向），到其他地方去获取资源 404 Not Found（没找到），无法找到这个资源 1.4.3 Web页面中可以包含多个对象：应用程序完成一项任务时通常会发布多个HTTP事务，就是当获取一个丰富的Web页面的时候。浏览器会执行一个事务来获取描述页面布局的HTML“框架”，然后发布另外的HTTP事务来获取每个嵌入式的图片、图像面板、java小程序等。这些资源甚至可能位于不同的服务器上。 1.5 后面再详讲 1.6 连接：HTTP协议使用TCP（传输控制协议）来传输其报文数据，在HTTP客户端口号在客户端和服务器之间建立一条TCP/IP连接。TCP使用IP地址和端口号来建立连接。 1.7 协议版本 1.8 Web的结构组件 （1）代理：HTTP代理服务器，这是Web安全、应用集成以及性能优化的重要组成模块。位于客户端和服务器之间，接受所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。出于安全考虑，通常会将代理作为转发所有Web流量的可信用中间节点使用。代理还可以对请求和响应进行过滤。 （2）缓存：Web缓存（Web cache）或代理缓存（Proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。 （3）网关：网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。例如，一个HTTP/FTP网关会通过HTTP请求接收对FTP URI的请求，单但通过FTP协议来获取文档。 （4）隧道：隧道（tunnel）是建立起来后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。 （5）Agent代理：用户Agent代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ消息队列（一）:Detailed Introduction 详细介绍]]></title>
    <url>%2F2018%2F01%2F03%2FRabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-Detailed-Introduction-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1、RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue）的开源实现。AMQP 的出现其实也是应了广大人民群众的需求，虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。2、RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购。在2013年5月被并入Pivotal。其实VMWare，Pivotal和EMC本质上是一家的。不同的是VMWare是独立上市子公司，而Pivotal是整合了EMC的某些资源，现在并没有上市。3、RabbitMQ的官网是http://www.rabbitmq.com 一、应用场景 对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： 1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据以如何方式丢失？ 2）如何降低发送者和接收者的耦合度？ 3）如何让Priority高的接收者先接到数据？ 4）如何做到load balance？有效均衡接收者的负载？ 5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter？ 6）如何做到可扩展，甚至将这个通信模块发到cluster上？ 7）如何保证接收者接收到了完整，正确的数据？AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 二、系统架构 成为系统架构可能不太合适，可能叫应用场景的系统架构更合适。这个系统架构图版权属于sunjun041640。RabbitMQ Server： 也叫broker server，它不是运送食物的卡车，而是一种传输服务。原话是RabbitMQisn’t a food truck, it’s a delivery service. 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。但是这个保证也不是100%的保证，但是对于普通的应用来说这已经足够了。当然对于商业系统来说，可以再做一层数据一致性的guard，就可以彻底保证系统的一致性了。 Client A &amp; B： 也叫Producer，数据的发送方。createmessages and publish (send) them to a broker server (RabbitMQ).一个Message有两个部分：payload（有效载荷）和label（标签）。payload顾名思义就是传输的数据。label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer。AMQP仅仅描述了label，而RabbitMQ决定了如何使用这个label的规则。 Client 1，2，3：也叫Consumer，数据的接收方。Consumersattach to a broker server (RabbitMQ) and subscribe to a queue。把queue比作是一个有名字的邮箱。当有Message到达某个邮箱后，RabbitMQ把它发送给它的某个订阅者即Consumer。当然可能会把同一个Message发送给很多的Consumer。在这个Message中，只有payload，label已经被删掉了。对于Consumer来说，它是不知道谁发送的这个信息的。就是协议本身不支持。但是当然了如果Producer发送的payload包含了Producer的信息就另当别论了。 对于一个数据从Producer到Consumer的正确传递，还有三个概念需要明确：exchanges, queues and bindings。 1、Exchanges are where producers publish their messages：Exchanges是生产者发布消息的地方 2、Queuesare where the messages end up and are received by consumers：Queuesare才是消息最终被消费者接受的地方 3、Bindings are how the messages get routed from the exchange to particular queues：绑定是消息从Exchange路由到特定Queuesare的方式 还有几个概念是上述图中没有标明的，那就是Connection（连接），Channel（通道，频道）。 Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 那么，为什么使用Channel，而不是直接使用TCP连接？ 对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。有实验表明，1s的时间可以Publish10K的数据包。当然对于不同的硬件环境，不同的数据包大小这个数据肯定不一样，但是我只想说明，对于普通的Consumer或者Producer来说，这已经足够了。如果不够用，你考虑的应该是如何细化split你的设计。 三、进一步的细节阐明 使用ack确认Message的正确传递 默认情况下，如果Message已经被某个Consumer正确的接收到了，那么该Message就会被从queue中移除。当然也可以让同一个Message发送到很多的Consumer。如果一个queue没被任何的Consumer Subscribe（订阅），那么，如果这个queue有数据到达，那么这个数据会被cache，不会被丢弃。当有Consumer时，这个数据会被立即发送到这个Consumer，这个数据被Consumer正确收到时，这个数据就被从queue中删除。 那么什么是正确收到呢？通过ack。每个Message都要被acknowledged（确认，ack）。我们可以显示的在程序中去ack，也可以自动的ack。如果有数据没有被ack，那么：RabbitMQ Server会把这个信息发送到下一个Consumer。如果这个app有bug，忘记了ack，那么RabbitMQ Server不会再发送数据给它，因为Server认为这个Consumer处理能力有限。而且ack的机制可以起到限流的作用（Benefitto throttling）：在Consumer处理完成数据后发送ack，甚至在额外的延时后发送ack，将有效的balance Consumer的load。 当然对于实际的例子，比如我们可能会对某些数据进行merge，比如merge 4s内的数据，然后sleep 4s后再获取数据。特别是在监听系统的state，我们不希望所有的state实时的传递上去，而是希望有一定的延时。这样可以减少某些IO，而且终端用户也不会感觉到。Reject a message有两种方式，第一种的Reject可以让RabbitMQ Server将该Message 发送到下一个Consumer。第二种是从queue中立即删除该Message。Creating a queue Consumer和Procuder都可以通过 queue.declare 创建queue。对于某个Channel来说，Consumer不能declare一个queue，却订阅其他的queue。当然也可以创建私有的queue。这样只有app本身才可以使用这个queue。queue也可以自动删除，被标为auto-delete的queue在最后一个Consumer unsubscribe后就会被自动删除。那么如果是创建一个已经存在的queue呢？那么不会有任何的影响。需要注意的是没有任何的影响，也就是说第二次创建如果参数和第一次不一样，那么该操作虽然成功，但是queue的属性并不会被修改。 那么谁应该负责创建这个queue呢？是Consumer，还是Producer？如果queue不存在，当然Consumer不会得到任何的Message。但是如果queue不存在，那么Producer Publish的Message会被丢弃。所以，为了数据不丢失，Consumer和Producer都try to create the queue！反正不管怎么样，这个接口都不会出问题。 queue对load balance的处理是完美的。对于多个Consumer来说，RabbitMQ 使用循环的方式（round-robin）的方式均衡的发送给不同的Consumer。 四、Exchanges 从架构图可以看出，Procuder Publish的Message进入了Exchange。接着通过“routing keys”， RabbitMQ会找到应该把这个Message放到哪个queue里。queue也是通过这个routing keys来做的绑定。有三种类型的Exchanges：direct,fanout,topic。每个实现了不同的路由算法（routing algorithm）。 Direct exchange: 如果 routing key 匹配, 那么Message就会被传递到相应的queue中。其实在queue创建时，它会自动的以queue的名字作为routing key来绑定那个exchange。 Fanout exchange: 会向响应的queue广播。 Topic exchange: 对key进行模式匹配，比如ab可以传递到所有ab的queue。 五、Virtual hosts 每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bings rule等等。这保证了你可以在多个不同的application中使用RabbitMQ。 接下来我会使用Python来说明RabbitMQ的使用方法。]]></content>
      <categories>
        <category>Advanced Message Queue</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis keys 命令]]></title>
    <url>%2F2017%2F12%2F24%2FRedis-keys-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Redis 键命令用于管理 redis 的键假如在Redis中有个键值对：username=admin 该命令用于在 key 存在时删除 key del key 例如：del username 当username确实存在并成功删除后返回(integer)1 如果username不存在则返回(integer)0 序列化给定 key ，并返回被序列化的值dump key 例如：dump username 检查给定 key 是否存在exists key 例如：exists username 如果存在返回(integer)1 否则：返回(integer)0 为给定 key 设置过期时间，以秒来记expire key seconds 例如：expire username 60 expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)expireat key timestamp 设置 key 的过期时间以毫秒计pexpire key millseconds 例如pexpire username 60000 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计pexpireat key millseconds-timestamp 查找所有符合给定模式( pattern)的 keykeys pattern 例如：keys * 查找所有的key 将当前数据库的 key 移动到给定的数据库 db 当中move key db redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。假如我们想把username移动到索引为1的数据库，则 move username 1 这个时候再在当前0数据库下exists username 将会返回0 我们可以通过select 1切换到1数据库，再输入exists username 则会返回1 移除 key 的过期时间，key 将持久保持persist key 如果key已经是持久的就会返回(integer)0 以毫秒为单位返回 key 的剩余的过期时间pttl key 如果key是持久的就会返回(integer)-1 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)ttl key 如果key是持久的就会返回(integer)-1 从当前数据库中随机返回一个 keyrandomkey 修改 key 的名称rename key newkey 当newkey存在的时候，会将当前key的值覆盖到newkey的值 仅当 newkey 不存在时，将 key 改名为 newkeyrenamenx key newkey 当newkey存在的时候将会返回0 返回 key 所储存的值的类型type key 例如：type username 返回string类型]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
